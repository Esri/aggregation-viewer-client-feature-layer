<!--
  Copyright 1995-2017 Esri

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

  For additional information, contact:
  Environmental Systems Research Institute, Inc.
  Attn: Contracts Dept
  380 New York Street
  Redlands, California, USA 92373

  email: contracts@esri.com
-->

<!DOCTYPE html>

<html>

<head lang="en">
  <meta charset="UTF-8">

  <title>Aggregation Viewer - Client Side Feature Layer</title>

  <link rel="stylesheet" href="https://js.arcgis.com/3.44/esri/css/esri.css">
  <link rel="stylesheet" href="./featureServiceViewerStyles.css">

  <script src="https://use.fontawesome.com/9482a0b1d1.js"></script>
  <script src="https://js.arcgis.com/3.44/"></script>
  <script>
    require([
      "dojo/parser",
      "dojo/dom",
      "dojo/dom-style",
      "dojo/dom-class",
      "dojo/on",
      "dojo/json",
      "dojo/_base/array",
      "dojo/query",
      "dojo/number",

      "esri/map",
      "esri/graphic",
      "esri/SpatialReference",
      "esri/Color",
      "esri/request",
      "esri/geometry/webMercatorUtils",
      "esri/geometry/Extent",
      "esri/tasks/GeometryService",
      "esri/InfoTemplate",
      "esri/TimeExtent",
      "esri/graphicsUtils",

      "esri/IdentityManager",

      "esri/layers/FeatureLayer",
      "esri/layers/LabelClass",
      "esri/layers/ArcGISDynamicMapServiceLayer",

      "esri/symbols/SimpleLineSymbol",
      "esri/symbols/SimpleFillSymbol",
      "esri/symbols/TextSymbol",
      "esri/geometry/Polygon",

      "esri/dijit/TimeSlider",

      "esri/renderers/HeatmapRenderer",
      "esri/renderers/ClassBreaksRenderer",

      "dijit/layout/BorderContainer",
      "dijit/layout/ContentPane",
      "dijit/TitlePane",
      "dijit/TooltipDialog",
      "dijit/form/DropDownButton",
      "dijit/form/Select",

      "dojo/query!css2",
      "dojo/domReady!"
    ], function (
      parser, dom, domStyle, domClass, on, JSON, array, domQuery, number,
      Map, Graphic, SpatialReference, Color, esriRequest, webMercatorUtils, Extent, GeometryService, InfoTemplate, TimeExtent, graphicsUtils,
      IdentityManager,
      FeatureLayer, LabelClass, ArcGISDynamicMapServiceLayer,
      SimpleLineSymbol, SimpleFillSymbol, TextSymbol, Polygon,
      TimeSlider,
      HeatmapRenderer, ClassBreaksRenderer,
      BorderContainer, ContentPane, TitlePane, TooltipDialog, DropDownButton, Select) {

      parser.parse();

      // ### global variables ###
      var _map;
      var _layerTimeExtent;
      var _replay = false;
      var _live = false;
      var _startTimeSlider = true;
      var _minValue;
      var _maxValue;
      var _ignoreChangeEvent = false;
      var _layerInfo;
      
      // ### Spatial Reference variables ###
      // These variables manage coordinate system transformations and spatial reference handling
      var _defaultWkid = 102100; // Web Mercator - default coordinate system
      var _wkid = 102100;         // Current working coordinate system ID
      var _currentMapSR = 102100; // Current map spatial reference system
      
      // ### Geometry Service for spatial reference transformations ###
      var _gs = new GeometryService("https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer");

      //#############################################################################################
      // Map Related functions
      //#############################################################################################

      esri.config.defaults.io.corsEnabledServers.push('http://storm.esri.com');
      esri.config.defaults.io.corsEnabledServers.push('http://storm.esri.com:6080');
      esri.config.defaults.io.corsEnabledServers.push('https://storm.esri.com:6443');
      esri.config.defaults.io.corsEnabledServers.push('http://localhost:9000');

      // ### Initialize map with default extent ###
      var initMapExtent = new Extent({
        "xmin": -20037508.342787,
        "ymin": -20037508.342787,
        "xmax": 20037508.342787,
        "ymax": 20037508.342787,
        "spatialReference": {"wkid": _defaultWkid}
      });

      // Build initial map with the default extent
      buildMap(initMapExtent);

      /**
       * Builds or rebuilds the map with the specified extent and current spatial reference
       * This function destroys any existing map and creates a new one with proper spatial reference
       * @param {Extent} mapExtent - The extent to set for the new map
       */
      function buildMap(mapExtent) {

        if (_map) {
          // Destroy existing map if it exists
          _map.removeAllLayers();
          _map.destroy();
          _map = null;
          console.log("Destroyed previous map instance for spatial reference change");
        }

        // Create new map with the specified extent
        _map = new Map("map", {
          wrapAround180: true,
          extent: mapExtent,
          showLabels: true,
          showAttribution: false,
          sliderStyle: "small"
        });

        _map.on("load", function () {
          console.log("Map loaded successfully.");
          setFeatureLayers();
        });

        // Attach extent change handler
        attachMapExtentChangeHandler();

        // Add the basemap
        var basemapUrl = dom.byId("basemapUrl").value;
        var basemapLayer;
        basemapLayer = new ArcGISDynamicMapServiceLayer(basemapUrl, {
          "showAttribution": false,
          "opacity": 1.0
        });
        _map.addLayers([basemapLayer]);

        // Update current map SR display
        dom.byId("currentMapSR").value = _wkid;
      }

      // ### Issue new query on extent-change if live mode is disabled ###
      // Note: This event handler will be re-attached when map is rebuilt
      function attachMapExtentChangeHandler() {
        _map.on("extent-change", function (evt) {
          if (_map.getLayer("aggregations") && !_ignoreChangeEvent && !_live) {
            updateLayerFromUIChange();
          }
        });
      }

      //#############################################################################################
      // UI Related functions
      //#############################################################################################

      // ### UI event listener ###
      
      // ### DRY: Reusable section toggle function ###
      function createSectionToggle(sectionId, toggleId, visibilityVar) {
        return function () {
          // toggle section visibility
          if (visibilityVar.value) {
            domClass.add(dojo.byId(sectionId), "section-hidden");
            domClass.replace(domQuery("#" + toggleId + " i")[0], "fa-chevron-down", "fa-chevron-up");
          } else {
            domClass.remove(dojo.byId(sectionId), "section-hidden");
            domClass.replace(domQuery("#" + toggleId + " i")[0], "fa-chevron-up", "fa-chevron-down");
          }
          visibilityVar.value = !visibilityVar.value;
        };
      }

      // ### Section visibility state objects ###
      var layersVisibility = { value: true };
      var aggSettingsVisibility = { value: true };
      var streamingModeVisibility = { value: true };
      var spatialReferenceVisibility = { value: true };
      var lodSRVisibility = { value: true };
      var aggLabelsVisibility = { value: true };

      // ### Section toggle event handlers ###
      on(dojo.byId("layersToggle"), "click", createSectionToggle("layersSection", "layersToggle", layersVisibility));
      on(dojo.byId("aggSettingsToggle"), "click", createSectionToggle("aggSettingsSection", "aggSettingsToggle", aggSettingsVisibility));
      on(dojo.byId("streamingModeToggle"), "click", createSectionToggle("streamingModeSection", "streamingModeToggle", streamingModeVisibility));
      on(dojo.byId("spatialReferenceToggle"), "click", createSectionToggle("spatialReferenceSection", "spatialReferenceToggle", spatialReferenceVisibility));
      on(dojo.byId("lodSRToggle"), "click", createSectionToggle("lodSRSection", "lodSRToggle", lodSRVisibility));
      on(dojo.byId("aggLabelsToggle"), "click", createSectionToggle("aggLabelsMainSection", "aggLabelsToggle", aggLabelsVisibility));

      on(dojo.byId("setLayerButton"), "click", setFeatureLayers);
      on(dojo.byId("heatmap"), "change", toggleHeatmap);
      on(dojo.byId("refreshMode"), "change", toggleMode);
      on(dojo.byId("autoOffSet"), "change", toggleRefresh);
      on(dojo.byId("aggStyle"), "change", toggleRefresh);
      on(dojo.byId("aggSubStyle"), "change", toggleRefresh);
      on(dojo.byId("lod"), "change", toggleRefresh);
      on(dojo.byId("blurRadius"), "change", toggleRefresh);
      on(dom.byId("useStats"), "change", toggleStats);

      on(dijit.byId("statField"), "change", statFieldChanged);
      on(dijit.byId("statType"), "change", updateLayerFromUIChange);
      
      // ### Spatial Reference event handlers ###
      on(dijit.byId("spatialReferenceSelect"), "change", onSpatialReferenceChange);
      
      // ### Aggregation Labels event handlers ###
      on(dijit.byId("labelFont"), "change", updateLayerFromUIChange);
      on(dojo.byId("labelSize"), "change", updateLayerFromUIChange);
      on(dojo.byId("labelColor"), "change", updateLayerFromUIChange);
      on(dojo.byId("labelOpacity"), "change", updateLayerFromUIChange);
      on(dojo.byId("renderLabels"), "change", toggleLabels);
      
      // ### LOD SR event handlers ###
      on(dijit.byId("lodSpatialReference"), "change", updateLayerFromUIChange);
      on(dojo.byId("useLodSR"), "change", updateLayerFromUIChange);

      on(document.getElementsByClassName("collapser")[0], "click", togglePanel);


      function setFeatureLayers() {

        // Remove existing feature layers
        var aggregationsLayer = _map.getLayer("aggregations");
        if (aggregationsLayer) {
          _map.removeLayer(aggregationsLayer);
        } else {
          console.log("Aggregations layer not found.");
        }

        var heatmapLayer = _map.getLayer("heatmap");
        if (heatmapLayer) {
          _map.removeLayer(heatmapLayer);
        } else {
          console.log("Heatmap layer not found.");
        }

        var aggregationsLayer = addAggregationsLayer();
        aggregationsLayer.on("load", function () {
          queryLayerTimeExtent();
          addHeatmapLayer();
          updateLayerFromUIChange(true);
        });
      }

      function togglePanel() {
        domClass.toggle(document.getElementsByTagName("body")[0], "panel-collapsed");
      }

      // ### Switch change functions ###

      function toggleMode(evt) {
        //console.log(evt.target.value);
        if (evt.target.value === "manual") {
          _live = false;
          _replay = false;
          domStyle.set(dom.byId('timeSlider'), "display", 'none');
          _map.setTimeSlider(null);
          _map.setTimeExtent(null);
          updateLayerFromUIChange();
        } else if (evt.target.value === "live") {
          _live = true;
          _replay = false;
          autoUpdate();
          domStyle.set(dom.byId('timeSlider'), "display", 'none');
          _map.setTimeSlider(null);
          _map.setTimeExtent(null);
        } else if (evt.target.value === "replay") {
          _live = false;
          _replay = true;
          if (_startTimeSlider) {
            initTimeSlider();
            _startTimeSlider = false;
          } else {
            _ignoreChangeEvent = true;
            updateTimeSlider();
          }
          domStyle.set(dom.byId('timeSlider'), "display", 'block');
        }
      }

      function toggleHeatmap(evt) {
        if (dojo.byId("heatmap").checked === true) {
          dojo.byId("radius").style.display = "inherit";
          var layer = _map.getLayer("heatmap");
          var minIsFinit = isFinite(_minValue);
          var maxIsFinit = isFinite(_maxValue);
          if (!minIsFinit) {
            _minValue = 0;
          }
          if (!maxIsFinit) {
            _maxValue = 1;
          }
          layer.renderer.setMinPixelIntensity(_minValue);
          layer.renderer.setMaxPixelIntensity(_maxValue);
        } else {
          dojo.byId("radius").style.display = "none";
        }
        updateLayerFromUIChange();
      }

      function toggleRefresh(evt) {
        if (!_live) {
          updateLayerFromUIChange();
        }
      }

      function toggleStats(evt) {
        if (evt.target.id === "useStats") {
          if (dojo.byId("useStats").checked === true) {
            dojo.byId("statField").style.display = "block";
            dojo.byId("statType").style.display = "block";
          } else {
            dojo.byId("statField").style.display = "none";
            dojo.byId("statType").style.display = "none";
          }
          updateLayerFromUIChange();
        }
      }

      function statFieldChanged(val) {
        var control = dijit.byId('statField');
        var selectedOption = control.getOptions(val);
        populateStatTypeSelectOptions(selectedOption);
        updateLayerFromUIChange();
      }

      // ### Spatial Reference Functions ###
      /**
       * Handles spatial reference system changes from the dropdown
       * Updates global variables and re-projects map if necessary
       * @param {string|number} newWkid - The new spatial reference WKID
       */
      function onSpatialReferenceChange(newWkid) {
        _wkid = parseInt(newWkid);

        // Check if the map's current spatial reference matches the new one
        if (_map && _map.spatialReference && _wkid === _map.spatialReference.wkid) {
          return; // No need to rebuild the map
        }

        // Update the current map spatial reference
        _currentMapSR = _wkid;

        // Project the map's current extent to the new spatial reference
        projectMapToSR(_wkid);
      }

      /**
       * Projects the current map extent to a new spatial reference system using geometry service
       * @param {number} wkid - The target spatial reference WKID
       */
      function projectMapToSR(wkid) {
        var sr = new SpatialReference(wkid);
        var project = _gs.project([_map.extent], sr);
        project.then(function (result) {
          if (result.length) {
            var newMapExtent = result[0];
            buildMap(newMapExtent); // Rebuild the map with the new extent
            dom.byId("currentMapSR").value = _wkid;
          } else {
            console.log("Projection was successful, but no results were returned.");
          }
        }, function (err) {
          console.log("Project Map to SR failed: ", err);
          // Fallback: build map with default extent for the new spatial reference
          var defaultExtent = new Extent({
            "xmin": -20037508.342787,
            "ymin": -20037508.342787,
            "xmax": 20037508.342787,
            "ymax": 20037508.342787,
            "spatialReference": { "wkid": wkid }
          });
          buildMap(defaultExtent);
          dom.byId("currentMapSR").value = _wkid;
        });
      }


      // ### Aggregation Labels Functions ###
      /**
       * Toggles the visibility of aggregation labels and their control panel
       * @param {Event} evt - The change event from the checkbox
       */
      function toggleLabels(evt) {
        // Toggle label visibility and show/hide label controls
        if (evt.target.id === "renderLabels") {
          if (dojo.byId("renderLabels").checked === true) {
            dojo.byId("aggLabelsSection").style.display = "block";
          } else {
            dojo.byId("aggLabelsSection").style.display = "none";
          }
          updateLayerFromUIChange();
        }
      }

      function populateStatTypeSelectOptions(selectedOption) {
        var statTypeSelect = dijit.byId("statType");
        var prevStatType = statTypeSelect.value;

        // clear statTypeSelect
        statTypeSelect.removeOption(statTypeSelect.getOptions());

        // find the field by name
        var fieldName = dijit.byId("statField").value;
        var field = null;
        for (i = 0; i < _layerInfo.fields.length; i++) {
          var currentField = _layerInfo.fields[i];
          if (currentField.name === fieldName)
            field = currentField;
        }

        // add the stat type options
        var statTypeOptions = null;
        if (isFieldNumeric(field)) {
          // add all types
          var options = [ {'label':'Average', 'value':'avg'},
                          {'label':'Maximum', 'value':'max'},
                          {'label':'Minimum', 'value':'min'},
                          {'label':'Standard Deviation', 'value':'stddev'},
                          {'label':'Sum', 'value':'sum'},
                          {'label':'Variance', 'value':'var'},
                          {'label':'Count Distinct', 'value':'countdistinct'},
                          {'label':'Count', 'value':'count'} ];
          statTypeSelect.addOption(options);
        } else {
          // add only the count and count distince types
          var options = [ {'label':'Count Distinct', 'value':'countdistinct'},
                          {'label':'Count', 'value':'count'} ];
          statTypeSelect.addOption(options);
        }

        updateLayerFromUIChange();
      }

      function getLayerInfo() {
        var url = dojo.byId("inputUrl").value;
        var mapServiceInfoDeferred = esri.request({
          url: url,
          content: {
            f: 'json'
          },
          callbackParamName: "callback"
        });
        mapServiceInfoDeferred.then(function (response) {
              _layerInfo = response;
              populateDijitSelectWithLayerFields(dijit.byId('statField'), false);
              statFieldChanged(dijit.byId('statField').value); // to init-populate the stat types control
            }
        );
      }

      function populateDijitSelectWithLayerFields(select, numericOnly) {
        // clear exiting options
        select.removeOption(select.getOptions());

        // populate options based on the _layerInfo.fields array
        var i;
        for (i = 0; i < _layerInfo.fields.length; i++) {
          var field = _layerInfo.fields[i];
          var fieldType = field.type.substring(13);
          var option = {'label': field.name + "&nbsp;&nbsp;" + "<em class='fieldTypeSelect'>" + fieldType + '</em>', 'value': field.name, 'type': field.type };
          if (numericOnly) {
            if (isFieldNumeric(field))
              select.addOption(option);
          } else {
            if (isSupportedStatField(field))
              select.addOption(option);
          }
        }
      }

      function populateSelectWithLayerFields(select, numericOnly) {
        // clear exiting options
        var i;
        for (i = select.options.length - 1; i >= 0; i--) {
          select.remove(i);
        }

        // populate options based on the layerFields array
        var pos = 0;
        for (i = 0; i < layerFields.length; i++) {
          var field = _layerInfo.fields[i];
          if (numericOnly) {
            if (isFieldNumeric(field))
              select.options[pos++] = new Option(field.name, field.name);
          } else {
            if (isSupportedStatField(field))
              select.options[pos++] = new Option(field.name, field.name);
          }
        }
      }

      // field type can be one of the following: "esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeString", "esriFieldTypeDate", "esriFieldTypeOID", "esriFieldTypeGeometry", "esriFieldTypeBlob", "esriFieldTypeRaster", "esriFieldTypeGUID", "esriFieldTypeGlobalID", "esriFieldTypeXML"
      function isFieldNumeric(field) {
          if (!field || !field.type)
            return false;

          return (field.type === "esriFieldTypeSmallInteger" || field.type === "esriFieldTypeInteger" || field.type === "esriFieldTypeSingle" || field.type === "esriFieldTypeDouble" || field.type === "esriFieldTypeOID");
      }

      function isSupportedStatField(field) {
          if (!field || !field.type)
            return false;

          return (field.type !== "esriFieldTypeGeometry" && field.type !== "esriFieldTypeBlob" && field.type !== "esriFieldTypeRaster");
      }

      //#############################################################################################
      // Layer related functions
      //#############################################################################################


      // ### Add Aggregation Layer ###

      function addAggregationsLayer() {
        var layerDefinition = {
          "geometryType": "esriGeometryPolygon",
          "fields": [
            {
              "name": "objectid",
              "type": "esriFieldTypeInteger",
              "alias": "objectid"
            }, {
              "name": "Geohash",
              "type": "esriFieldTypeString",
              "alias": "Geohash"
            }, {
              "name": "Count",
              "type": "esriFieldTypeInteger",
              "alias": "Count"
            }, {
              "name": "Weight",
              "type": "esriFieldTypeDouble",
              "alias": "Weight"
            }, {
              "name": "Geometry",
              "type": "esriFieldTypeGeometry",
              "alias": "Geometry"
            }
          ]
        };
        var featureCollection = {
          layerDefinition: layerDefinition,
          featureSet: null
        };
        var infoTemplate = new InfoTemplate("Attributes", "${*}");
        var aggregationsLayer = new FeatureLayer(featureCollection, {
          id: "aggregations",
          objectIdField: "objectid",
          showLabels: true,
          infoTemplate: infoTemplate,
          outFields: ["*"]
        });

        aggregationsLayer.setRenderer(createRenderer("Aggregation"));
        
        // Only set labels if renderLabels is checked
        if (dojo.byId("renderLabels") && dojo.byId("renderLabels").checked === true) {
          var label = createRenderer("Label");
          aggregationsLayer.setLabelingInfo([label]);
        }
        
        _map.addLayer(aggregationsLayer);
        console.log("Client Aggregations Layer added");

        getLayerInfo();
        return aggregationsLayer
      };

      // ### Heat Map Feature Layer ###

      function addHeatmapLayer() {
        var layerDefinition = {
          "geometryType": "esriGeometryPoint",
          "fields": [{
            "name": "objectid",
            "type": "esriFieldTypeInteger",
            "alias": "objectid"
                }, {
            "name": "Geohash",
            "type": "esriFieldTypeString",
            "alias": "Geohash"
                }, {
            "name": "Count",
            "type": "esriFieldTypeInteger",
            "alias": "Count"
                }, {
            "name": "Weight",
            "type": "esriFieldTypeDouble",
            "alias": "Weight"
                }, {
            "name": "geometry",
            "type": "esriFieldTypeGeometry",
            "alias": ""
                }]
        };

        var featureCollection = {
          layerDefinition: layerDefinition,
          featureSet: null
        };

        var heatmapLayer = new FeatureLayer(featureCollection, {
          id: "heatmap",
          objectIdField: "objectid",
          visible: true,
          opacity: 1
        });

        heatmapLayer.setRenderer(createRenderer("Heatmap"));
        _map.addLayer(heatmapLayer);
        //console.log("Heatmap Layer added");
      };

      // ### FeatureLayer Time Info query###

      function queryLayerTimeExtent() {
        var url = dojo.byId("inputUrl").value + "?f=json";
        var request = esriRequest({
          "url": url,
          "handleAs": "json",
          "callbackParamName": "callback"
        });
        request.then(
          function (response) {
            _layerTimeExtent = new TimeExtent(new Date(response.timeInfo.timeExtent[0]), new Date(response.timeInfo.timeExtent[1]));
          },
          function (error) {
            console.log("Error getting the layers time extent: ", error.message);
          });
      };

      //#############################################################################################
      //Create Renderer or Labels
      //#############################################################################################
      //
      function createRenderer(type) {
        // ### Aggregation Renderer ###
        if (type === "Aggregation") {
          // define default symbol
          var symbol = new SimpleFillSymbol();
          symbol.setColor(new Color([150, 150, 150, 0.3]))
            .setOutline(new SimpleLineSymbol().setColor(new Color("white")).setWidth(0.3));
          // function to create symbol for breaks with a given color
          function createSymbol(color) {
            return new SimpleFillSymbol()
              .setColor(color)
              .setOutline(
                new SimpleLineSymbol().setColor(new Color([99, 99, 99, 1])).setWidth(0.3)
              );
          };
          classColorInfo = [];

          // define breaks and color
          var renderer = new ClassBreaksRenderer({
            field: "Weight",
            defaultSymbol: symbol,
            normalizationType: "percent-of-total",
            normalizationTotal: 100,
            classBreakInfos: [
              {
                minValue: 0,
                maxValue: 10,
                symbol: createSymbol(new Color([254, 240, 217, 0.7]))
              },
              {
                minValue: 10,
                maxValue: 20,
                symbol: createSymbol(new Color([253, 212, 158, 0.7]))
              },
              {
                minValue: 20,
                maxValue: 30,
                symbol: createSymbol(new Color([253, 187, 132, 0.8]))
              },
              {
                minValue: 30,
                maxValue: 40,
                symbol: createSymbol(new Color([252, 141, 89, 0.8]))
              },
              {
                minValue: 40,
                maxValue: 60,
                symbol: createSymbol(new Color([239, 101, 72, 0.9]))
              },
              {
                minValue: 60,
                maxValue: 80,
                symbol: createSymbol(new Color([215, 48, 31, 0.9]))
              },
              {
                minValue: 80,
                maxValue: 100,
                symbol: createSymbol(new Color([153, 0, 0, 1]))
              }
            ]
          });


          // ### HeatMap Renderer ###
        } else if (type === "Heatmap") {
          var renderer = new HeatmapRenderer({
            colorStops: [
              {
                ratio: 0,
                color: "rgba(250, 0, 0, 0)"
                    },
              {
                ratio: 0.3,
                color: "rgba(0,128,255, 1)"
                    },
              {
                ratio: 0.4,
                color: "rgba(115,185,139, 1)"
                    },
              {
                ratio: 0.5,
                color: "rgba(185,220,69, 1)"
                    },
              {
                ratio: 0.6,
                color: "rgba(255,255,0, 1)"
                    },
              {
                ratio: 0.7,
                color: "rgb(255,220,0)"
                    },
              {
                ratio: 0.9,
                color: "rgb(255,174,0)"
                    },
              {
                ratio: 0.97,
                color: "rgb(255,112,0)"
                    },
              {
                ratio: 0.98,
                color: "rgb(255,80,0)"
                    },
              {
                ratio: 0.999,
                color: "rgb(255, 0, 0)"
                    }],
            blurRadius: 12,
            field: "Weight"
          });

          // ### Add Labels ###
        } else if (type === "Label") {

          // Get label configuration from UI controls
          var labelFont = dijit.byId("labelFont") ? dijit.byId("labelFont").value : "arial";
          var labelSize = dojo.byId("labelSize") ? dojo.byId("labelSize").value + "pt" : "8pt";
          var labelColorHex = dojo.byId("labelColor") ? dojo.byId("labelColor").value : "#000000";
          var labelOpacity = dojo.byId("labelOpacity") ? parseFloat(dojo.byId("labelOpacity").value) : 1.0;
          
          // Convert hex color to RGB with opacity
          var labelColor = hexToRgb(labelColorHex);
          if (labelColor) {
            labelColor = [labelColor.r, labelColor.g, labelColor.b, labelOpacity];
          } else {
            labelColor = [0, 0, 0, labelOpacity]; // Default to black
          }

          // create a text symbol and renderer to define the style of labels
          var labelJson = {
            "labelExpressionInfo": {
              "value": "{Weight}"
            },
            "labelPlacement": "always-horizontal"
          };
          var lc = new LabelClass(labelJson);
          var gridLabel = new TextSymbol().setColor(new Color(labelColor));
          gridLabel.font.setSize(labelSize);
          gridLabel.font.setFamily(labelFont);
          lc.symbol = gridLabel;
          var renderer = lc;
        }
        return renderer;
      }

      // ### Utility Functions ###
      /**
       * Converts a hexadecimal color string to RGB values
       * Used for processing label color settings from the UI
       * @param {string} hex - Hexadecimal color string (e.g., "#FF0000")
       * @returns {Object|null} RGB object with r, g, b properties or null if invalid
       */
      function hexToRgb(hex) {
        // Convert hex color to RGB using regex pattern matching
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }

      //#############################################################################################
      // BDS FS Aggregation Query
      //#############################################################################################
      function buildQueryUrlFromUI() {
        var timeParam = "";
        if (_replay) {
          var start = _layerTimeExtent.startTime.getTime();
          var end = _layerTimeExtent.endTime.getTime();
          timeParam = "&time=" + start + "," + end;
        } else if (_live) {
          var now = new Date().getTime();
          timeParam = "&time=null," + now;
        }

        var lod = dojo.byId("lod").value;
        var subStyle = dojo.byId("aggSubStyle").value;
        var style = dojo.byId("aggStyle").value;
        if (dojo.byId("autoOffSet").checked === true) {
          if (style === "flatHexagon" || style === "pointyHexagon" || style === "square" || style === 'geotile') {
            lod = (parseInt(lod) + 5).toString();
          } else if (style === "flatTriangle" || style === "pointyTriangle") {
            lod = (parseInt(lod) + 4).toString();
          } else if (style === 'h3') {
            lod = (parseInt(lod) + 4).toString();
          }
        }

        var url = dojo.byId("inputUrl").value;
        
        // Determine output spatial reference - use LOD SR if enabled, otherwise use current map SR
        var outputSR = _currentMapSR;
        if (dojo.byId("useLodSR") && dojo.byId("useLodSR").checked === true) {
          outputSR = dijit.byId("lodSpatialReference").value;
        }
        
        url += "/query?lod=" + lod + "&lodType=" + style + "&lodSubType=" + subStyle + "&outSR=" + outputSR + "&returnGeometry=true" + timeParam;

        // TODO - for now, add the spatial filter to the query, only for point geometry layers
        if (_layerInfo && _layerInfo.geometryType && _layerInfo.geometryType === "esriGeometryPoint") {
          var ext = encodeURIComponent(JSON.stringify(_map.extent.toJson()));
          url += "&geometryType=esriGeometryEnvelope&geometry=" + ext;
        }

        url += "&f=pjson";

        if (dojo.byId("useStats").checked === true) {
          var outStatisticsObj = [ {
            "statisticType": dijit.byId("statType").value,
            "onStatisticField": dijit.byId("statField").value,
            "outStatisticFieldName": dijit.byId("statField").value + "_" + dijit.byId("statType").value
          } ];
          var outStatisticsStr = JSON.stringify(outStatisticsObj);
          url += "&outStatistics=" + encodeURIComponent(outStatisticsStr);
        }

        //console.log(url);
        return url;
      }

      function updateLayerFromUIChange(setMapExtent) {
        // Use current map spatial reference or LOD SR if enabled
        var outputSR = _currentMapSR;
        if (dojo.byId("useLodSR") && dojo.byId("useLodSR").checked === true) {
          outputSR = dijit.byId("lodSpatialReference").value;
        }
        var sr = new SpatialReference(parseInt(outputSR));
        var mapSR = new SpatialReference(_map.spatialReference.wkid);

        var url = buildQueryUrlFromUI();
        var request = esriRequest({
          "url": url,
          "handleAs": "json",
          "callbackParamName": "callback"
        });
        request.then(
          function (response) {
            //console.log(response);

            var aggregationsLayer = _map.getLayer("aggregations");
            var heatmapLayer = _map.getLayer("heatmap");
            if (!aggregationsLayer || !heatmapLayer)
              return;

            var weightsArray = [];

            // If the output SR is different from map SR, we need to project geometries
            if (parseInt(outputSR) !== _map.spatialReference.wkid) {
              // Project all geometries to map's spatial reference
              var geometriesToProject = [];
              array.forEach(response.features, function(feature) {
                if (feature && feature.geometry) {
                  feature.geometry.spatialReference = sr.toJson();
                  geometriesToProject.push(new Polygon(feature.geometry));
                }
              });

              if (geometriesToProject.length > 0) {
                var projectTask = _gs.project(geometriesToProject, mapSR);
                projectTask.then(function(projectedGeometries) {
                  processProjectedFeatures(response.features, projectedGeometries, weightsArray, setMapExtent);
                }, function(error) {
                  console.log("Error projecting geometries:", error);
                  // Fallback: process without projection
                  processFeatures(response.features, weightsArray, setMapExtent);
                });
              }
            } else {
              // No projection needed
              processFeatures(response.features, weightsArray, setMapExtent);
            }
          },
          function (error) {
            console.log("Error querying the aggregations: ", error.message);
          });
      }

      function processProjectedFeatures(features, projectedGeometries, weightsArray, setMapExtent) {
        var graphics = array.map(features, function (feature, i) {
          var geometry = projectedGeometries[i];

          if (dojo.byId("heatmap").checked === true) {
            geometry = geometry.getCentroid();
          }

          var weight = 0;
          if (dojo.byId("useStats").checked === true) {
            var weightFieldName = dijit.byId("statField").value + "_" + dijit.byId("statType").value;
            weight = feature.attributes[weightFieldName];
          } else {
            weight = feature.attributes["Count"];
          }
          feature.attributes["Weight"] = number.round(weight, 2);
          weightsArray.push(weight);

          var graphic = new Graphic(geometry, null, feature.attributes, null);
          return graphic;
        });

        updateLayersWithGraphics(graphics, weightsArray, setMapExtent);
      }

      function processFeatures(features, weightsArray, setMapExtent) {
        var mapSR = new SpatialReference(_map.spatialReference.wkid);
        
        // create features (graphics) from the response features
        var graphics = array.map(features, function (feature, i) {
            // Ensure the geometry has the correct spatial reference that matches the map
            if (feature && feature.geometry) {
              // Set the spatial reference to match the map's spatial reference
              feature.geometry['spatialReference'] = mapSR.toJson();
            }

            // create the polygon
            var geometry = new Polygon(feature.geometry);

            if (dojo.byId("heatmap").checked === true) {
              geometry = geometry.getCentroid();
            }

            var weight = 0;
            if (dojo.byId("useStats").checked === true) {
              var weightFieldName = dijit.byId("statField").value + "_" + dijit.byId("statType").value;
              weight = feature.attributes[weightFieldName];
            } else {
              weight = feature.attributes["Count"];
            }
            feature.attributes["Weight"] = number.round(weight, 2);
            weightsArray.push(weight);

            var graphic = new Graphic(geometry, null, feature.attributes, null);
            return graphic;
        });

        updateLayersWithGraphics(graphics, weightsArray, setMapExtent);
      }

      function updateLayersWithGraphics(graphics, weightsArray, setMapExtent) {
        var aggregationsLayer = _map.getLayer("aggregations");
        var heatmapLayer = _map.getLayer("heatmap");

        // add features to the respective selected layer and adjust renderer
        var selectedLayer = null;
        var otherLayer = null;
        if (dojo.byId("heatmap").checked === true) {
          selectedLayer = heatmapLayer;
          otherLayer = aggregationsLayer;
          heatmapLayer.renderer.setBlurRadius(dojo.byId("blurRadius").value);
        } else {
          selectedLayer = aggregationsLayer;
          otherLayer = heatmapLayer;

          // calculate min and max weight values to adjust heatmap renderer
          _minValue = Math.min.apply(null, weightsArray);
          _maxValue = Math.max.apply(null, weightsArray);
          aggregationsLayer.renderer.normalizationTotal = _maxValue;
        }

        // update features layer with new features (graphics)
        otherLayer.setVisibility(false);
        selectedLayer.clear();
        selectedLayer.setVisibility(true);
        selectedLayer.applyEdits(graphics, null, null)
          .then(function () {
            if (setMapExtent && graphics.length > 0) {
              var layerExtent = graphicsUtils.graphicsExtent(graphics);
              if (layerExtent)
                _map.setExtent(layerExtent.expand(1.0));
            }
            selectedLayer.refresh();
          });
      }


      //#############################################################################################
      //Other Functions
      //#############################################################################################
      //

      //
      // Time Slider (init & update incl. labels)
      //
      function initTimeSlider() {
        timeSlider = new TimeSlider({
          style: "width: 100%;"
        }, dom.byId("timeSlider"));
        _map.setTimeSlider(timeSlider);
        timeSlider.setThumbCount(2);
        timeSlider.createTimeStopsByCount(_layerTimeExtent, 21);
        timeSlider.setThumbIndexes([0, 21]);
        timeSlider.setThumbMovingRate(2000);
        timeSlider.startup();
        timeSlider.on("time-extent-change", function () {
          if (!_ignoreChangeEvent) {
            _layerTimeExtent = timeSlider.getCurrentTimeExtent();
            updateLayerFromUIChange();
          };
        });
        // add labels for every other time stop
        var labels = createLabels();
        timeSlider.setLabels(labels);
      }

      function updateTimeSlider() {
        queryLayerTimeExtent();
        setTimeout(function () {
          timeSlider.createTimeStopsByCount(_layerTimeExtent, 21);
          timeSlider.setThumbIndexes([0, 21]);
          timeSlider.startup();
          _map.setTimeSlider(timeSlider);
          // add labels for every other time stop
          var labels = createLabels();
          timeSlider.setLabels(labels);
          domStyle.set(dom.byId('timeSlider'), "display", 'block');
          updateLayerFromUIChange();
          _ignoreChangeEvent = false;
        }, 1000);
      }

      // time slider labels
      function createLabels() {
        var labels = array.map(timeSlider.timeStops, function (timeStop, i) {
          if (i % 2 === 0) {
            if (timeStop.getHours() < 10) {
              var hours = "0" + timeStop.getHours();
            } else {
              var hours = timeStop.getHours();
            };
            if (timeStop.getMinutes() < 10) {
              var minutes = "0" + timeStop.getMinutes();
            } else {
              var minutes = timeStop.getMinutes();
            };
            if (timeStop.getSeconds() < 10) {
              var seconds = "0" + timeStop.getSeconds();
            } else {
              var seconds = timeStop.getSeconds();
            };
            var month = timeStop.getMonth() + 1;
            var day = timeStop.getDate();
            //return hours + ":" + minutes;
            return month + "/" + day + "<br>" + hours + ":" + minutes + ":" + seconds;
          } else {
            return "";
          }
        });
        return labels;
      }

      function autoUpdate() {
        setTimeout(function () {
          updateLayerFromUIChange();
          if (_live) {
            autoUpdate();
          }
        }, 2000);
      }

      on(dom.byId("inputUrl"), "mouseenter", function() {
        this.title = this.value || "No value entered";
      });
      on(dom.byId("inputUrl"), "mouseleave", function() {
        this.title = "";
      });

    });
  </script>
</head>

<body class="flat">
  <div id="map"></div>
  <div id="timeSlider"></div>
  <div class="collapser">
    <i id="collapserIcon" class="flat-chevron-right"></i>
    <i id="expanderIcon" class="flat-chevron-left"></i>
  </div>
  <div id="controls">
    <section id="layersSection">
      <div class="config-header">
        <h2>Layers</h2>
        <div class="header-actions-group">
          <a href="#" id="layersToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
        <!-- <div class="header-actions-group">
          <div data-dojo-type="dijit/form/DropDownButton">
            <span><i class="fa fa-plus"></i></span>
            <div data-dojo-type="dijit/TooltipDialog" style="display: none;">
              <label for="name2">Name:</label> <input data-dojo-type="dijit/form/TextBox" id="name2" name="name2" /><br />
              <label for="hobby2">Hobby:</label> <input data-dojo-type="dijit/form/TextBox" id="hobby2" name="hobby2" /><br />
              <button data-dojo-type="dijit/form/Button" type="submit">Save</button>
            </div>
          </div>
        </div> -->
      </div>
      <div class="config-content">
        <input type="text" id="inputUrl" value="https://storm.esri.com:6443/arcgis/rest/services/faa/MapServer/0" />
        <input type="button" class="button" id="setLayerButton" value="Set Layer" />
      </div>
    </section>

    <!-- Spatial Reference Section -->
    <section id="spatialReferenceSection">
      <div class="config-header">
        <h2>Spatial Reference</h2>
        <div class="header-actions-group">
          <a href="#" id="spatialReferenceToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content">
        <div class="input-group">
          <select name="spatialReferenceSelect" data-dojo-type="dijit/form/Select" id="spatialReferenceSelect" style="width: 200px;">
            <option value="102003">102003 (Albers)</option>
            <option value="102100" selected="selected">102100 (Web Mercator)</option>
            <option value="4326">4326 (WGS84)</option>
            <option value="54030">54030 (Robinson)</option>
            <option value="26911">26911 (NAD83 / UTM zone 11N)</option>
            <option value="27700">27700 (British National Grid)</option>
            <option value="2243">2243 (Idaho West, State Plane)</option>
            <option value="2244">2244 (Indiana East, State Plane)</option>
            <option value="2248">2248 (Maryland, State Plane)</option>
            <option value="3995">3995 (Arctic Polar Stereographic)</option>
            <option value="2271">2271 (NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="2272">2272 (NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
            <option value="3363">3363 (NAD_1983_HARN_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="3365">3365 (NAD_1983_HARN_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
          </select>
          <label for="spatialReferenceSelect">Coordinate System</label>
        </div>
        <div class="input-group">
          <input type="text" id="currentMapSR" value="102100" readonly style="width: 80px;" />
          <label for="currentMapSR">Current Map SR</label>
        </div>
      </div>
    </section>

    <section id="aggSettingsSection">
      <div class="config-header">
        <h2>Aggregation Settings</h2>
        <div class="header-actions-group">
          <a href="#" id="aggSettingsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content">
        <div class="input-group">
          <select name="aggStyle" id="aggStyle" style="width: 120px;">
            <option value="geohash" selected="selected">GeoHash</option>
            <option value="geotile">GeoTile</option>
            <option value="h3">H3</option>
            <option value="square">Square</option>
            <option value="flatHexagon">Flat Hexagon</option>
            <option value="pointyHexagon">Pointy Hexagon</option>
            <option value="flatTriangle">Flat Triangle</option>
            <option value="pointyTriangle">Pointy Triangle</option>
          </select>
          <label for="aggStyle">GeoHash Style</label>
        </div>
        <div class="input-group">
          <input type="number" id="lod" value="3" style="width: 50px;" />
          <label for="lod">LOD</label>
        </div>
        <div class="input-group">
          <input type="checkbox" id="autoOffSet" checked="true" />
          <label for="autoOffSet">Auto LOD offset</label>
        </div>
        <div class="input-group">
          <select name="aggSubStyle" id="aggSubStyle" style="width: 120px;">
            <option value="shape">Shape</option>
            <option value="centroid" selected="selected">Centroid</option>
          </select>
          <label for="aggSubStyle">Geohash SubStyle</label>
        </div>
        <div class="input-group">
          <input type="checkbox" id="heatmap" />
          <label for="heatmap">Heatmap</label>
        </div>
        <div id="radius" class="input-group" style="display:none">
          <input type="number" id="blurRadius" value="10" style="width: 40px;" />
          <label for="blurRadius">BlurRadius</label>
        </div>
        <div class="input-group">
          <input type="checkbox" id="useStats" style="top:4px;"/>
          <label for="useStats">Statistics</label>
        </div>
        <div style="display:inline-block;width:100%;">
          <select name="statField" data-dojo-type="dijit/form/Select" data-dojo-attach-point="statField" id="statField" style="width: 250px; margin-top:3px; display:none; float:left;">
          </select>
          <select name="statType"  data-dojo-type="dijit/form/Select" data-dojo-attach-point="statType" id="statType" style="width: 250px; margin-top:3px; display:none; float:left;">
          </select>
        </div>
      </div>
    </section>

    <!-- LOD Spatial Reference Section -->
    <section id="lodSRSection">
      <div class="config-header">
        <h2>LOD Spatial Reference</h2>
        <div class="header-actions-group">
          <a href="#" id="lodSRToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content">
        <div class="input-group">
          <select name="lodSpatialReference" data-dojo-type="dijit/form/Select" id="lodSpatialReference" style="width: 200px;">
            <option value="102003">102003 (Albers)</option>
            <option value="102100" selected="selected">102100 (Web Mercator)</option>
            <option value="4326">4326 (WGS84)</option>
            <option value="54030">54030 (Robinson)</option>
            <option value="26911">26911 (NAD83 / UTM zone 11N)</option>
            <option value="27700">27700 (British National Grid)</option>
            <option value="2243">2243 (Idaho West, State Plane)</option>
            <option value="2244">2244 (Indiana East, State Plane)</option>
            <option value="2248">2248 (Maryland, State Plane)</option>
            <option value="3995">3995 (Arctic Polar Stereographic)</option>
            <option value="2271">2271 (NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="2272">2272 (NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
            <option value="3363">3363 (NAD_1983_HARN_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="3365">3365 (NAD_1983_HARN_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
          </select>
          <label for="lodSpatialReference">LOD Coordinate System</label>
        </div>
        <div class="input-group">
          <input type="checkbox" id="useLodSR" />
          <label for="useLodSR">Use Different SR for LOD</label>
        </div>
      </div>
    </section>

    <!-- Aggregation Labels Section -->
    <section id="aggLabelsMainSection">
      <div class="config-header">
        <h2>Aggregation Labels</h2>
        <div class="header-actions-group">
          <a href="#" id="aggLabelsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content">
        <div class="input-group">
          <input type="checkbox" id="renderLabels" />
          <label for="renderLabels">Show Labels</label>
        </div>
        <div id="aggLabelsSection" style="display:none;">
          <div class="input-group">
            <select name="labelFont" data-dojo-type="dijit/form/Select" id="labelFont" style="width: 150px;">
              <option value="arial" selected="selected">Arial</option>
              <option value="helvetica">Helvetica</option>
              <option value="times">Times</option>
              <option value="courier">Courier</option>
              <option value="verdana">Verdana</option>
            </select>
            <label for="labelFont">Font Family</label>
          </div>
          <div class="input-group">
            <input type="number" id="labelSize" value="8" min="6" max="24" style="width: 60px;" />
            <label for="labelSize">Font Size (pt)</label>
          </div>
          <div class="input-group">
            <input type="color" id="labelColor" value="#000000" style="width: 50px;" />
            <label for="labelColor">Font Color</label>
          </div>
          <div class="input-group">
            <input type="range" id="labelOpacity" min="0" max="1" step="0.1" value="1" style="width: 100px;" />
            <label for="labelOpacity">Opacity</label>
          </div>
        </div>
      </div>
    </section>

    <section id="streamingModeSection">
      <div class="config-header">
        <h2>Streaming Mode</h2>
        <div class="header-actions-group">
          <a href="#" id="streamingModeToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content">
        <div class="input-group">
          <select name="aggStreamMode" id="refreshMode" style="width: 120px;">
            <option value="manual">Manual</option>
            <option value="live">Live</option>
            <option value="replay">Replay</option>
          </select>
          <label for="refreshMode">Mode</label>
        </div>
      </div>
    </section>

    <!-- Add basemap dropdown UI control -->
    <div>
      <label for="basemapUrl">Select Basemap:</label>
      <select id="basemapUrl">
        <option value="https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer">World Street Map</option>
        <option value="https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer">World Topographic Map</option>
        <option value="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer">World Imagery</option>
      </select>
    </div>
  </div>
</body>
</html>
