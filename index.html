<!--
  Copyright 1995-2017 Esri

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

  For additional information, contact:
  Environmental Systems Research Institute, Inc.
  Attn: Contracts Dept
  380 New York Street
  Redlands, California, USA 92373

  email: contracts@esri.com
-->

<!DOCTYPE html>

<html>

<head lang="en">
  <meta charset="UTF-8">

  <title>Aggregation Viewer - Client Side Feature Layer</title>

  <link rel="stylesheet" href="https://js.arcgis.com/3.46/esri/css/esri.css">
  <link rel="stylesheet" href="./featureServiceViewerStyles.css">

  <script src="https://use.fontawesome.com/9482a0b1d1.js"></script>
  <script src="https://js.arcgis.com/3.46/"></script>
  <script>
    require([
      "dojo/parser",
      "dojo/dom",
      "dojo/dom-style",
      "dojo/dom-class",
      "dojo/on",
      "dojo/json",
      "dojo/_base/array",
      "dojo/query",
      "dojo/number",

      "esri/map",
      "esri/graphic",
      "esri/SpatialReference",
      "esri/Color",
      "esri/request",
      "esri/geometry/webMercatorUtils",
      "esri/geometry/Extent",
      "esri/tasks/GeometryService",
      "esri/InfoTemplate",
      "esri/TimeExtent",
      "esri/graphicsUtils",

      "esri/IdentityManager",

      "esri/layers/FeatureLayer",
      "esri/layers/LabelClass",
      "esri/layers/ArcGISDynamicMapServiceLayer",
      "esri/layers/ArcGISTiledMapServiceLayer",

      "esri/symbols/SimpleLineSymbol",
      "esri/symbols/SimpleFillSymbol",
      "esri/symbols/TextSymbol",
      "esri/geometry/Polygon",

      "esri/dijit/TimeSlider",

      "esri/renderers/HeatmapRenderer",
      "esri/renderers/ClassBreaksRenderer",

      "dijit/layout/BorderContainer",
      "dijit/layout/ContentPane",
      "dijit/TitlePane",
      "dijit/TooltipDialog",
      "dijit/form/DropDownButton",
      "dijit/form/Select",

      "dojo/query!css2",
      "dojo/domReady!"
    ], function (
      parser, dom, domStyle, domClass, on, JSON, array, domQuery, number,
      Map, Graphic, SpatialReference, Color, esriRequest, webMercatorUtils, Extent, GeometryService, InfoTemplate, TimeExtent, graphicsUtils,
      IdentityManager,
      FeatureLayer, LabelClass, ArcGISDynamicMapServiceLayer, ArcGISTiledMapServiceLayer,
      SimpleLineSymbol, SimpleFillSymbol, TextSymbol, Polygon,
      TimeSlider,
      HeatmapRenderer, ClassBreaksRenderer,
      BorderContainer, ContentPane, TitlePane, TooltipDialog, DropDownButton, Select) {

      parser.parse();

      // ### global variables ###
      let _map;
      let _layerTimeExtent;
      let _replay = false;
      let _live = false;
      let _startTimeSlider = true;
      let _minValue;
      let _maxValue;
      let _ignoreChangeEvent = false;
      let _layerInfo;
      let _timeSlider;
      const _binRendererProps = {};
      
      // ### Spatial Reference variables ###
      // These variables manage coordinate system transformations and spatial reference handling
      const _defaultWkid = 102100; // Web Mercator - default coordinate system
      let _wkid = 102100;         // Current working coordinate system ID
      let _currentMapSR = 102100; // Current map spatial reference system
      
      // ### Geometry Service for spatial reference transformations ###
      const _gs = new GeometryService("https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer");

      // Define _isBasemapTiled with a default value
      let _isBasemapTiled = true; // Set to true if tiled basemaps are the default, otherwise false

      //#############################################################################################
      // Map Related functions
      //#############################################################################################

      esri.config.defaults.io.corsEnabledServers.push('http://storm.esri.com');
      esri.config.defaults.io.corsEnabledServers.push('http://storm.esri.com:6080');
      esri.config.defaults.io.corsEnabledServers.push('https://storm.esri.com:6443');
      esri.config.defaults.io.corsEnabledServers.push('http://localhost:9000');

      // ### Initialize map with default extent ###
      const initMapExtent = new Extent({
        "xmin": -20037508.342787,
        "ymin": -20037508.342787,
        "xmax": 20037508.342787,
        "ymax": 20037508.342787,
        "spatialReference": {"wkid": _defaultWkid}
      });

      // Build initial map with the default extent
      buildMap(initMapExtent);

      /**
       * Builds or rebuilds the map with the specified extent and current spatial reference
       * This function destroys any existing map and creates a new one with proper spatial reference
       * @param {Extent} mapExtent - The extent to set for the new map
       */
      function buildMap(mapExtent) {

        if (_map) {
          // Destroy existing map if it exists
          _map.removeAllLayers();
          _map.destroy();
          _map = null;
          console.log("Destroyed previous map instance for spatial reference change");
        }

        // Create new map with the specified extent
        _map = new Map("map", {
          wrapAround180: true,
          extent: mapExtent,
          showLabels: true,
          showAttribution: false,
          sliderStyle: "small"
        });

        _map.on("load", function () {
          console.log("Map loaded successfully.");
          setFeatureLayers();
        });

        // Attach extent change handler
        attachMapExtentChangeHandler();

        // Add the basemap
        const basemapUrl = dom.byId("basemapUrl").value;
        let basemapLayer;
        basemapLayer = new ArcGISDynamicMapServiceLayer(basemapUrl, {
          "showAttribution": false,
          "opacity": 1.0
        });
        _map.addLayers([basemapLayer]);

        // only the first map built is tiled
        _isBasemapTiled = false;
      }

      /**
       * Issue new query on extent-change if live mode is disabled ###
       * Note: This event handler will be re-attached when map is rebuilt
       */
       function attachMapExtentChangeHandler() {
        _map.on("extent-change", function (evt) {
          if (_map.getLayer("aggregations") && !_ignoreChangeEvent && !_live) {
            updateLayerFromUIChange();
          }
        });
      }

      //#############################################################################################
      // UI Related functions
      //#############################################################################################

      /*
       * DRY: Reusable section toggle function
       * This function creates a toggle handler for a section based on its ID and visibility state
       * @param {string} sectionId - The ID of the section to toggle
       * @param {string} toggleId - The ID of the toggle button
       * @param {Object} visibilityVar - An object to track the visibility state of the section
       */
      function createSectionToggle(sectionId, toggleId, visibilityVar) {
        return function () {
          // toggle section visibility
          if (visibilityVar.value) {
            domClass.add(dojo.byId(sectionId), "section-hidden");
            domClass.replace(domQuery("#" + toggleId + " i")[0], "fa-chevron-down", "fa-chevron-up");
          } else {
            domClass.remove(dojo.byId(sectionId), "section-hidden");
            domClass.replace(domQuery("#" + toggleId + " i")[0], "fa-chevron-up", "fa-chevron-down");
          }
          visibilityVar.value = !visibilityVar.value;
        };
      }

      // ### Section visibility state objects ###
      const layersVisibility = { value: true };
      const aggSettingsVisibility = { value: true };
      const aggStyleVisibility = { value: false };
      const aggBinsVisibility = { value: true };
      const streamingModeVisibility = { value: true };
      const aggLabelsVisibility = { value: true };

      //#############################################################################################
      // ### UI Event Listeners ###
      //#############################################################################################

      // ### Section toggle event handlers ###
      on(dojo.byId("layersToggle"), "click", createSectionToggle("layersSection", "layersToggle", layersVisibility));
      on(dojo.byId("aggSettingsToggle"), "click", createSectionToggle("aggSettingsSection", "aggSettingsToggle", aggSettingsVisibility));
      on(dojo.byId("aggStyleToggle"), "click", createSectionToggle("aggStyleSection", "aggStyleToggle", aggStyleVisibility));
      on(dojo.byId("aggBinsToggle"), "click", createSectionToggle("aggBinsSection", "aggBinsToggle", aggBinsVisibility));
      on(dojo.byId("streamingModeToggle"), "click", createSectionToggle("streamingModeSection", "streamingModeToggle", streamingModeVisibility));
      on(dojo.byId("aggLabelsToggle"), "click", createSectionToggle("aggLabelsMainSection", "aggLabelsToggle", aggLabelsVisibility));

      on(dojo.byId("setLayerButton"), "click", setFeatureLayers);
      on(dojo.byId("heatmap"), "change", toggleHeatmap);
      on(dojo.byId("refreshMode"), "change", toggleMode);
      on(dojo.byId("autoOffSet"), "change", toggleRefresh);
      on(dojo.byId("lodType"), "change", toggleRefresh);
      on(dojo.byId("lodGeometryAggregationType"), "change", toggleRefresh);
      on(dojo.byId("lod"), "change", toggleRefresh);
      on(dojo.byId("blurRadius"), "change", toggleRefresh);
      on(dom.byId("useStats"), "change", toggleStats);

      on(dijit.byId("statField"), "change", statFieldChanged);
      on(dijit.byId("statType"), "change", updateLayerFromUIChange);
      
      // ### Spatial Reference event handlers ###
      on(dijit.byId("spatialReferenceSelect"), "change", onSpatialReferenceChange);

      // ### Aggregation Renderer event handlers ###
      on(dojo.byId("useAggregationRenderer"), "change", toggleUseAggregationRenderer);
      on(dojo.byId("minColor"), "change", updateRendererFromUI);
      on(dojo.byId("maxColor"), "change", updateRendererFromUI);
      on(dojo.byId("minColorA"), "change", updateRendererFromUI);
      on(dojo.byId("maxColorA"), "change", updateRendererFromUI);
      on(dojo.byId("minOutlineColor"), "change", updateRendererFromUI);
      on(dojo.byId("maxOutlineColor"), "change", updateRendererFromUI);
      on(dojo.byId("minOutlineColorA"), "change", updateRendererFromUI);
      on(dojo.byId("maxOutlineColorA"), "change", updateRendererFromUI);
      on(dojo.byId("minOutlineWidth"), "change", updateRendererFromUI);
      on(dojo.byId("maxOutlineWidth"), "change", updateRendererFromUI);
      on(dojo.byId("minSize"), "change", updateRendererFromUI);
      on(dojo.byId("maxSize"), "change", updateRendererFromUI);
      on(dojo.byId("minValue"), "change", updateRendererFromUI);
      on(dojo.byId("maxValue"), "change", updateRendererFromUI);
      on(dojo.byId("classBreaksCount"), "change", updateRendererFromUI);

      // ### Aggregation Labels event handlers ###
      on(dojo.byId("renderLabels"), "change", updateRendererFromUI);
      on(dijit.byId("labelFont"), "change", updateRendererFromUI);
      on(dijit.byId("labelStyle"), "change", updateRendererFromUI);
      on(dijit.byId("labelWeight"), "change", updateRendererFromUI);
      on(dojo.byId("labelSize"), "change", updateRendererFromUI);
      on(dojo.byId("labelColor"), "change", updateRendererFromUI);
      on(dojo.byId("labelOpacity"), "change", updateRendererFromUI);
      
      // ### LOD SR event handlers ###
      on(dijit.byId("lodSR"), "change", updateLayerFromUIChange);
      on(dojo.byId("useLodSR"), "change", updateLayerFromUIChange);

      on(document.getElementsByClassName("collapser")[0], "click", togglePanel);

      /**
       * Shows a tooltip with the current value of the input field
       * This function is called when the mouse enters the input field
       */
      on(dom.byId("inputUrl"), "mouseenter", function() {
        this.title = this.value || "No value entered";
      });

      /**
       * Clears the tooltip when the mouse leaves the input field
       * This function is called when the mouse leaves the input field
       */
      on(dom.byId("inputUrl"), "mouseleave", function() {
        this.title = "";
      });


      /**
       * Updates the feature layers based on the current UI settings
       * This function is called when the user clicks the "Set Layer" button
       */
      function setFeatureLayers() {

        // Remove existing feature layers
        const existingAggregationLayer = _map.getLayer("aggregations");
        if (existingAggregationLayer) {
          _map.removeLayer(existingAggregationLayer);
        } else {
          console.log("Aggregation layer not found.");
        }

        const heatmapLayer = _map.getLayer("heatmap");
        if (heatmapLayer) {
          _map.removeLayer(heatmapLayer);
        } else {
          console.log("Heatmap layer not found.");
        }

        const newAggregationLayer = addAggregationsLayer();
        newAggregationLayer.on("load", function () {
          queryLayerTimeExtent();
          addHeatmapLayer();
          updateLayerFromUIChange(true);
        });
      }

      /**
       * Toggles the visibility of the panel by adding or removing a CSS class
       * This function is used to collapse or expand the panel
       */
      function togglePanel() {
        domClass.toggle(document.getElementsByTagName("body")[0], "panel-collapsed");
      }

      // ### Switch change functions ###

      /*
       * Toggles the map interaction mode between manual, live, and replay
       * This function is called when the mode switch is changed
       */
      function toggleMode(evt) {
        if (evt.target.value === "manual") {
          _live = false;
          _replay = false;
          domStyle.set(dom.byId('timeSlider'), "display", 'none');
          _map.setTimeSlider(null);
          _map.setTimeExtent(null);
          updateLayerFromUIChange();
        } else if (evt.target.value === "live") {
          _live = true;
          _replay = false;
          autoUpdate();
          domStyle.set(dom.byId('timeSlider'), "display", 'none');
          _map.setTimeSlider(null);
          _map.setTimeExtent(null);
        } else if (evt.target.value === "replay") {
          _live = false;
          _replay = true;
          if (_startTimeSlider) {
            initTimeSlider();
            _startTimeSlider = false;
          } else {
            _ignoreChangeEvent = true;
            updateTimeSlider();
          }
          domStyle.set(dom.byId('timeSlider'), "display", 'block');
        }
      }

      /**
       * Toggles the heatmap layer on and off
       * This function is called when the heatmap toggle is changed
       */
      function toggleHeatmap(evt) {
        if (dojo.byId("heatmap").checked === true) {
          dojo.byId("radius").style.display = "inherit";
          const layer = _map.getLayer("heatmap");
          const minIsFinit = isFinite(_minValue);
          const maxIsFinit = isFinite(_maxValue);
          if (!minIsFinit) {
            _minValue = 0;
          }
          if (!maxIsFinit) {
            _maxValue = 1;
          }
          layer.renderer.setMinPixelIntensity(_minValue);
          layer.renderer.setMaxPixelIntensity(_maxValue);
        } else {
          dojo.byId("radius").style.display = "none";
        }
        updateLayerFromUIChange();
      }

      /**
       * Toggles the refresh of the layer
       * This function is called when the refresh toggle is changed
       */
      function toggleRefresh(evt) {
        if (!_live) {
          updateLayerFromUIChange();
        }
      }

      /**
       * Toggles the use of the aggregation renderer
       * This function is called when the useAggregationRenderer toggle is changed
       */
      function toggleStats(evt) {
        if (evt.target.id === "useStats") {
          if (dojo.byId("useStats").checked === true) {
            dojo.byId("statField").style.display = "block";
            dojo.byId("statType").style.display = "block";
          } else {
            dojo.byId("statField").style.display = "none";
            dojo.byId("statType").style.display = "none";
          }
          updateLayerFromUIChange();
        }
      }

      /**
       * Handles changes to the selected statistical field
       * This function is called when the statistical field dropdown is changed
       */
      function statFieldChanged(val) {
        const control = dijit.byId('statField');
        const selectedOption = control.getOptions(val);
        populateStatTypeSelectOptions(selectedOption);
        updateLayerFromUIChange();
      }

      //#############################################################################################
      // ### Spatial Reference Functions ###
      //#############################################################################################

      /**
       * Handles spatial reference system changes from the dropdown
       * Updates global variables and re-projects map if necessary
       * @param {string|number} newWkid - The new spatial reference WKID
       */
      function onSpatialReferenceChange(newWkid) {
        _wkid = parseInt(newWkid);

        // Check if the map's current spatial reference matches the new one
        if (_map && _map.spatialReference && _wkid === _map.spatialReference.wkid) {
          return; // No need to rebuild the map
        }

        // Update the current map spatial reference
        _currentMapSR = _wkid;

        // Project the map's current extent to the new spatial reference
        projectMapToSR(_wkid);
      }

      /**
       * Projects the current map extent to a new spatial reference system using geometry service
       * @param {number} wkid - The target spatial reference WKID
       */
      function projectMapToSR(wkid) {
        const sr = new SpatialReference(wkid);
        const project = _gs.project([_map.extent], sr);
        project.then(function (result) {
          if (result.length) {
            const newMapExtent = result[0];
            buildMap(newMapExtent); // Rebuild the map with the new extent
          } else {
            console.log("Projection was successful, but no results were returned.");
          }
        }, function (err) {
          console.log("Project Map to SR failed: ", err);
          // Fallback: build map with default extent for the new spatial reference
          const defaultExtent = new Extent({
            "xmin": -20037508.342787,
            "ymin": -20037508.342787,
            "xmax": 20037508.342787,
            "ymax": 20037508.342787,
            "spatialReference": { "wkid": wkid }
          });
          buildMap(defaultExtent);
        });
      }


      //#############################################################################################      
      // ### Aggregation Labels Functions ###
      //#############################################################################################

      /**
       * Toggles the visibility of aggregation labels and their control panel
       * @param {Event} evt - The change event from the checkbox
       */
      function toggleLabels(evt) {
        // Toggle label visibility and show/hide label controls
        if (evt.target.id === "renderLabels") {
          if (dojo.byId("renderLabels").checked === true) {
            dojo.byId("aggLabelsSection").style.display = "block";
          } else {
            dojo.byId("aggLabelsSection").style.display = "none";
          }
          updateLayerFromUIChange();
        }
      }

      /**
       * Populates the statistical type select options based on the selected field
       * @param {Object} selectedOption - The selected field option
       */
      function populateStatTypeSelectOptions(selectedOption) {
        const statTypeSelect = dijit.byId("statType");

        // clear statTypeSelect
        statTypeSelect.removeOption(statTypeSelect.getOptions());

        // find the field by name
        const statFieldElement = dijit.byId("statField");
        if (!statFieldElement) {
          console.warn("Element with ID 'statField' not found.");
          return;
        }
        const fieldName = statFieldElement.value;
        let field = null;
        for (let i = 0; i < _layerInfo.fields.length; i++) {
          const currentField = _layerInfo.fields[i];
          if (currentField.name === fieldName)
            field = currentField;
        }

        if (isFieldNumeric(field)) {
          // add all types
          const options = [ {'label':'Average', 'value':'avg'},
                          {'label':'Maximum', 'value':'max'},
                          {'label':'Minimum', 'value':'min'},
                          {'label':'Standard Deviation', 'value':'stddev'},
                          {'label':'Sum', 'value':'sum'},
                          {'label':'Variance', 'value':'var'},
                          {'label':'Count Distinct', 'value':'countdistinct'},
                          {'label':'Count', 'value':'count'} ];
          statTypeSelect.addOption(options);
        } else {
          // add only the count and count distinct types
          const options = [ {'label':'Count Distinct', 'value':'countdistinct'},
                          {'label':'Count', 'value':'count'} ];
          statTypeSelect.addOption(options);
        }

        updateLayerFromUIChange();
      }

      function getLayerInfo() {
        const url = dojo.byId("inputUrl").value;
        const mapServiceInfoDeferred = esri.request({
          url: url,
          content: {
            f: 'json'
          },
          callbackParamName: "callback"
        });
        mapServiceInfoDeferred.then(function (response) {
              _layerInfo = response;
              populateDijitSelectWithLayerFields(dijit.byId('statField'), false);
              statFieldChanged(dijit.byId('statField').value); // to init-populate the stat types control
            }
        );
      }

      function populateDijitSelectWithLayerFields(select, numericOnly) {
        // clear exiting options
        select.removeOption(select.getOptions());

        // populate options based on the _layerInfo.fields array
        for (let i = 0; i < _layerInfo.fields.length; i++) {
          const field = _layerInfo.fields[i];
          const fieldType = field.type.substring(13);
          const option = {'label': field.name + "&nbsp;&nbsp;" + "<em class='fieldTypeSelect'>" + fieldType + '</em>', 'value': field.name, 'type': field.type };
          if (numericOnly) {
            if (isFieldNumeric(field))
              select.addOption(option);
          } else {
            if (isSupportedStatField(field))
              select.addOption(option);
          }
        }
      }

      /**
       * Populates the select element with layer fields
       * @param {Object} select - The select element to populate
       * @param {boolean} numericOnly - Whether to include only numeric fields
       */
      function populateSelectWithLayerFields(select, numericOnly) {
        // clear exiting options
        for (let i = select.options.length - 1; i >= 0; i--) {
          select.remove(i);
        }

        // populate options based on the layerFields array
        let pos = 0;
        for (let i = 0; i < layerFields.length; i++) {
          const field = _layerInfo.fields[i];
          if (numericOnly) {
            if (isFieldNumeric(field))
              select.options[pos++] = new Option(field.name, field.name);
          } else {
            if (isSupportedStatField(field))
              select.options[pos++] = new Option(field.name, field.name);
          }
        }
      }

      /**
       * Checks if the field is numeric
       * @param {Object} field - The field object to check
       * @returns {boolean} True if the field is numeric, false otherwise
       */
      function isFieldNumeric(field) {
          if (!field || !field.type)
            return false;

          return (field.type === "esriFieldTypeSmallInteger" || field.type === "esriFieldTypeInteger" || field.type === "esriFieldTypeSingle" || field.type === "esriFieldTypeDouble" || field.type === "esriFieldTypeOID");
      }

      /**
       * Checks if the field is supported for statistical operations
       * @param {Object} field - The field object to check
       * @returns {boolean} True if the field is supported, false otherwise
       */
      function isSupportedStatField(field) {
          if (!field || !field.type)
            return false;

          return (field.type !== "esriFieldTypeGeometry" && field.type !== "esriFieldTypeBlob" && field.type !== "esriFieldTypeRaster");
      }


      //#############################################################################################
      // Layer related functions
      //#############################################################################################

      /**
       * Adds a client-side feature layer for aggregations with a predefined feature collection and renderer
       * This layer will be used to display aggregated data on the map
       * @returns {FeatureLayer} The created FeatureLayer instance
       */
      function addAggregationsLayer() {
        const layerDefinition = {
          "geometryType": "esriGeometryPolygon",
          "fields": [
            {
              "name": "objectid",
              "type": "esriFieldTypeInteger",
              "alias": "objectid"
            }, {
              "name": "Geohash",
              "type": "esriFieldTypeString",
              "alias": "Geohash"
            }, {
              "name": "Count",
              "type": "esriFieldTypeInteger",
              "alias": "Count"
            }, {
              "name": "Weight",
              "type": "esriFieldTypeDouble",
              "alias": "Weight"
            }, {
              "name": "Geometry",
              "type": "esriFieldTypeGeometry",
              "alias": "Geometry"
            }
          ]
        };
        const featureCollection = {
          layerDefinition: layerDefinition,
          featureSet: {
            features: [],
            geometryType: layerDefinition.geometryType
          }
        };
        const infoTemplate = new InfoTemplate("Attributes", "${*}");
        const aggregationLayer = new FeatureLayer(featureCollection, {
          id: "aggregations",
          objectIdField: "objectid",
          showLabels: true,
          infoTemplate: infoTemplate,
          outFields: ["*"]
        });

        // Create and set the bins renderer
        const renderer = dojo.byId("useAggregationRenderer").checked === true ? createAggregationRenderer() : createClassBreakRenderer();
        aggregationLayer.setRenderer(renderer);
        
        // Create and set the bin labels (if renderLabels is checked)
        if (dojo.byId("renderLabels") && dojo.byId("renderLabels").checked === true) {
          const labelClass = createLabelClass();
          aggregationLayer.setLabelingInfo([labelClass]);
        }
        
        _map.addLayer(aggregationLayer);
        console.log("Client Aggregation Layer added");

        getLayerInfo();
        return aggregationLayer
      }

      /**
       * Adds a heatmap layer to the map with a predefined feature collection and renderer
       */
      function addHeatmapLayer() {
        const layerDefinition = {
          "geometryType": "esriGeometryPoint",
          "fields": [{
            "name": "objectid",
            "type": "esriFieldTypeInteger",
            "alias": "objectid"
                }, {
            "name": "Geohash",
            "type": "esriFieldTypeString",
            "alias": "Geohash"
                }, {
            "name": "Count",
            "type": "esriFieldTypeInteger",
            "alias": "Count"
                }, {
            "name": "Weight",
            "type": "esriFieldTypeDouble",
            "alias": "Weight"
                }, {
            "name": "geometry",
            "type": "esriFieldTypeGeometry",
            "alias": ""
                }]
        };

        const featureCollection = {
          layerDefinition: layerDefinition,
          featureSet: {
            features: [],
            geometryType: layerDefinition.geometryType
          }
        };

        const heatmapLayer = new FeatureLayer(featureCollection, {
          id: "heatmap",
          objectIdField: "objectid",
          visible: true,
          opacity: 1
        });

        // Create and set the renderer for the heatmap layer
        const renderer = createHeatmapRenderer();
        heatmapLayer.setRenderer(renderer);

        _map.addLayer(heatmapLayer);
        console.log("Heatmap Layer added");
      }

      /**
       * Queries the feature layer's time extent and sets the global _layerTimeExtent variable
       * This function is called when the map is loaded or when the layer is set
       */
      function queryLayerTimeExtent() {
        const url = dojo.byId("inputUrl").value + "?f=json";
        const request = esriRequest({
          "url": url,
          "handleAs": "json",
          "callbackParamName": "callback"
        });
        request.then(
          function (response) {
            _layerTimeExtent = new TimeExtent(new Date(response.timeInfo.timeExtent[0]), new Date(response.timeInfo.timeExtent[1]));
          },
          function (error) {
            console.log("Error getting the layers time extent: ", error.message);
          });
      }

      /**
       * Loads the properties for the bin renderer from the UI inputs
       * This function reads values from the input fields and sets them in the _binRendererProps object
       * It is called when the aggregation renderer is used or when the properties need to be
       */
      function loadBinRendererProps() {
        _binRendererProps.classBreaksCount = dojo.byId("classBreaksCount") ? dojo.byId("classBreaksCount").value : 10;
        console.log("Creating an aggregation renderer with " + _binRendererProps.classBreaksCount + " class breaks");

        // min and max fill color and opacity
        const minColorHex = dojo.byId("minColor") ? dojo.byId("minColor").value : "#000000";
        const maxColorHex = dojo.byId("maxColor") ? dojo.byId("maxColor").value : "#000000";
        let minColorA = dojo.byId("minColorA") ? parseFloat(dojo.byId("minColorA").value / 255) : 1.0;
        if (isNaN(minColorA) || minColorA < 0 || minColorA > 1) {
          minColorA = 1.0; // Default to fully opaque if invalid
        }
        let maxColorA = dojo.byId("maxColorA") ? parseFloat(dojo.byId("maxColorA").value / 255) : 1.0;
        if (isNaN(maxColorA) || maxColorA < 0 || maxColorA > 1) {
          maxColorA = 1.0; // Default to fully opaque if invalid
        }
        _binRendererProps.minColor = hexToRgba(minColorHex, minColorA);
        _binRendererProps.maxColor = hexToRgba(maxColorHex, maxColorA);

        // min and max outline color and opacity
        const minOutlineColorHex = dojo.byId("minOutlineColor") ? dojo.byId("minOutlineColor").value : "#000000";
        const maxOutlineColorHex = dojo.byId("maxOutlineColor") ? dojo.byId("maxOutlineColor").value : "#000000";
        let minOutlineColorA = dojo.byId("minOutlineColorA") ? parseFloat(dojo.byId("minOutlineColorA").value / 255) : 1.0;
        if (isNaN(minOutlineColorA) || minOutlineColorA < 0 || minOutlineColorA > 1) {
          minOutlineColorA = 1.0; // Default to fully opaque if invalid
        }
        let maxOutlineColorA = dojo.byId("maxOutlineColorA") ? parseFloat(dojo.byId("maxOutlineColorA").value / 255) : 1.0;
        if (isNaN(maxOutlineColorA) || maxOutlineColorA < 0 || maxOutlineColorA > 1) {
          maxOutlineColorA = 1.0; // Default to fully opaque if invalid
        }
        _binRendererProps.minOutlineColor = hexToRgba(minOutlineColorHex, minOutlineColorA);
        _binRendererProps.maxOutlineColor = hexToRgba(maxOutlineColorHex, maxOutlineColorA);

        // min and max outline width
        _binRendererProps.minOutlineWidth = dojo.byId("minOutlineWidth") ? parseFloat(dojo.byId("minOutlineWidth").value) : 0.5;
        _binRendererProps.maxOutlineWidth = dojo.byId("maxOutlineWidth") ? parseFloat(dojo.byId("maxOutlineWidth").value) : 1.0;
      }

      /**
       * Interpolates a value between min and max.
       * @param {number} ratio - A value between 0 and 1
       * @param {number} min - The minimum value
       * @param {number} max - The maximum value
       * @returns {number} A value between min and max
       */
      function interpolate(ratio, min, max) {
        if (max === min) return max;
        return min + ratio * (max - min);
      }

      /**
       * Creates class break information for the renderer.
       * @param {number} min - The minimum value for the class break
       * @param {number} max - The maximum value for the class break
       * @returns {Object} An object containing the class break information
       */
      function createClassBreakInfo(min, max) {
        const ratio = max / 100;

        // fill color and opacity
        const fillR = interpolate(ratio, _binRendererProps.minColor[0], _binRendererProps.maxColor[0]);
        const fillG = interpolate(ratio, _binRendererProps.minColor[1], _binRendererProps.maxColor[1]);
        const fillB = interpolate(ratio, _binRendererProps.minColor[2], _binRendererProps.maxColor[2]);
        const fillA = interpolate(ratio, _binRendererProps.minColor[3], _binRendererProps.maxColor[3]);
        const fillColor = new Color([fillR, fillG, fillB, fillA]);
        const fillSymbol = new SimpleFillSymbol();

        // outline color and width
        const outlineR = interpolate(ratio, _binRendererProps.minOutlineColor[0], _binRendererProps.maxOutlineColor[0]);
        const outlineG = interpolate(ratio, _binRendererProps.minOutlineColor[1], _binRendererProps.maxOutlineColor[1]);
        const outlineB = interpolate(ratio, _binRendererProps.minOutlineColor[2], _binRendererProps.maxOutlineColor[2]);
        const outlineA = interpolate(ratio, _binRendererProps.minOutlineColor[3], _binRendererProps.maxOutlineColor[3]);
        const outlineColor = new Color([outlineR, outlineG, outlineB, outlineA]);
        const outlineWidth = interpolate(ratio, _binRendererProps.minOutlineWidth, _binRendererProps.maxOutlineWidth);
        fillSymbol
                .setStyle(SimpleFillSymbol.STYLE_SOLID)
                .setColor(fillColor)
                .setOutline(
                        new SimpleLineSymbol().setColor(outlineColor).setWidth(outlineWidth)
                );
        return {
          minValue: min,
          maxValue: max,
          symbol: fillSymbol
        };
      }

      /**
       * Builds class break infos for the aggregation renderer based on the bin renderer properties
       * This function creates an array of class break infos with interpolated colors and sizes
       * @returns {Array} An array of class break info objects
       */
      function buildAggregationRendererClassBreakInfos() {
        loadBinRendererProps();
        const classBreakInfos = [];
        const classSize = 100 / _binRendererProps.classBreaksCount;
        for (let i = 0; i < _binRendererProps.classBreaksCount; i++) {
          classBreakInfos.push(createClassBreakInfo(i * classSize, (i + 1) * classSize));
        }
        return classBreakInfos;
      }

      /**
       * Builds class break infos for a simple aggregation renderer with fixed breaks
       * This function creates an array of class break infos with predefined ranges
       * This is used for the simple aggregation renderer example
       * It creates fixed class breaks for demonstration purposes
       * It does not use the bin renderer properties
       * @returns {Array} An array of class break info objects
       */
      function buildAggregationRendererClassBreakInfos_Simple() {
        loadBinRendererProps();
        const classBreakInfos = [];
        classBreakInfos.push(createClassBreakInfo(0, 10));
        classBreakInfos.push(createClassBreakInfo(10, 20));
        classBreakInfos.push(createClassBreakInfo(20, 30));
        classBreakInfos.push(createClassBreakInfo(30, 40));
        classBreakInfos.push(createClassBreakInfo(40, 50));
        classBreakInfos.push(createClassBreakInfo(50, 60));
        classBreakInfos.push(createClassBreakInfo(60, 70));
        classBreakInfos.push(createClassBreakInfo(70, 80));
        classBreakInfos.push(createClassBreakInfo(80, 90));
        classBreakInfos.push(createClassBreakInfo(90, 100));
        return classBreakInfos;
      }

      /**
       * Creates a ClassBreaksRenderer for the aggregation layer
       * This renderer defines different color breaks based on the "Weight" field
       * @returns {ClassBreaksRenderer} The created ClassBreaksRenderer instance
       */
      function createAggregationRenderer() {
        const classBreakInfos = buildAggregationRendererClassBreakInfos();

        // define breaks and color
        const renderer = new ClassBreaksRenderer({
          field: "Weight",
          defaultSymbol: createClassBreakInfo(90, 100).symbol,
          normalizationType: "percent-of-total",
          normalizationTotal: 100,
          classBreakInfos: classBreakInfos
        });

        return renderer;
      }

      /**
       * Creates a ClassBreaksRenderer for the aggregation layer
       * This renderer defines different color breaks based on the "Weight" field
       * @returns {ClassBreaksRenderer} The created ClassBreaksRenderer instance
       */
       function createClassBreakRenderer() {
        console.log("Creating a class break renderer with 10 classes");

        // define default symbol
        const symbol = new SimpleFillSymbol();
        symbol.setColor(new Color([150, 150, 150, 0.3]))
          .setOutline(new SimpleLineSymbol().setColor(new Color("white")).setWidth(0.3));
        // function to create symbol for breaks with a given color
        function createSymbol(color) {
          return new SimpleFillSymbol()
            .setColor(color)
            .setOutline(
              new SimpleLineSymbol().setColor(new Color([99, 99, 99, 1])).setWidth(0.3)
            );
        };
        const classColorInfo = [];

        // define breaks and color
        const renderer = new ClassBreaksRenderer({
          field: "Weight",
          defaultSymbol: symbol,
          normalizationType: "percent-of-total",
          normalizationTotal: 100,
          classBreakInfos: [
            {
              minValue: 0,
              maxValue: 10,
              symbol: createSymbol(new Color([254, 240, 217, 0.7]))
            },
            {
              minValue: 10,
              maxValue: 20,
              symbol: createSymbol(new Color([253, 212, 158, 0.7]))
            },
            {
              minValue: 20,
              maxValue: 30,
              symbol: createSymbol(new Color([253, 187, 132, 0.8]))
            },
            {
              minValue: 30,
              maxValue: 40,
              symbol: createSymbol(new Color([252, 141, 89, 0.8]))
            },
            {
              minValue: 40,
              maxValue: 60,
              symbol: createSymbol(new Color([239, 101, 72, 0.9]))
            },
            {
              minValue: 60,
              maxValue: 80,
              symbol: createSymbol(new Color([215, 48, 31, 0.9]))
            },
            {
              minValue: 80,
              maxValue: 100,
              symbol: createSymbol(new Color([153, 0, 0, 1]))
            }
          ]
        });

        return renderer;        
      }

      /**
       * Creates a HeatmapRenderer for the heatmap layer
       * This renderer defines color stops and blur radius for the heatmap visualization
       * @returns {HeatmapRenderer} The created HeatmapRenderer instance
       */
      function createHeatmapRenderer() {
          const renderer =  new HeatmapRenderer({
            colorStops: [
              {
                ratio: 0,
                color: "rgba(250, 0, 0, 0)"
                    },
              {
                ratio: 0.3,
                color: "rgba(0,128,255, 1)"
                    },
              {
                ratio: 0.4,
                color: "rgba(115,185,139, 1)"
                    },
              {
                ratio: 0.5,
                color: "rgba(185,220,69, 1)"
                    },
              {
                ratio: 0.6,
                color: "rgba(255,255,0, 1)"
                    },
              {
                ratio: 0.7,
                color: "rgb(255,220,0)"
                    },
              {
                ratio: 0.9,
                color: "rgb(255,174,0)"
                    },
              {
                ratio: 0.97,
                color: "rgb(255,112,0)"
                    },
              {
                ratio: 0.98,
                color: "rgb(255,80,0)"
                    },
              {
                ratio: 0.999,
                color: "rgb(255, 0, 0)"
                    }],
            blurRadius: 12,
            field: "Weight"
          });

          return renderer;
      }

      /**
       * Creates a LabelClass for the feature layer
       * This class defines the labeling properties for the features
       * @returns {LabelClass} The created LabelClass instance
       */
      function createLabelClass() {
        // Get label configuration from UI controls
        const labelFont = dijit.byId("labelFont") ? dijit.byId("labelFont").value : "arial";
        const labelStyle = dijit.byId("labelStyle") ? dijit.byId("labelStyle").value : "normal";
        const labelWeight = dijit.byId("labelWeight") ? dijit.byId("labelWeight").value : "normal";
        const labelSize = dojo.byId("labelSize") ? dojo.byId("labelSize").value + "pt" : "9pt";
        const labelColorHex = dojo.byId("labelColor") ? dojo.byId("labelColor").value : "#000000";
        const labelOpacity = dojo.byId("labelOpacity") ? parseFloat(dojo.byId("labelOpacity").value) : 1.0;
        
        // Convert hex color to RGB with opacity
        let labelColor = hexToRgb(labelColorHex);
        if (labelColor) {
          labelColor = [labelColor.r, labelColor.g, labelColor.b, labelOpacity];
        } else {
          labelColor = [0, 0, 0, labelOpacity]; // Default to black
        }

        // Create a text symbol for the label
        const textSymbol = new TextSymbol().setColor(new Color(labelColor));
        textSymbol.font.setSize(labelSize);
        textSymbol.font.setFamily(labelFont);
        textSymbol.font.setStyle(toFontStyle(labelStyle));
        textSymbol.font.setWeight(toFontWeight(labelWeight));


        // Create a label class with label expression and text symbol
        const labelJson = {
          "labelExpressionInfo": {
            "value": "{Weight}"
          },
          "labelPlacement": "always-horizontal"
        };
        const labelClass = new LabelClass(labelJson);
        labelClass.symbol = textSymbol;
        
        return labelClass;
      }

      // ###############################################################################################
      // ### Utility Functions ###
      // ###############################################################################################

      /**
       * Converts label style string to a valid font style
       * @param {string} labelStyle - The label style string (e.g., "italic", "oblique")
       * @returns {string} The corresponding font style ("normal", "italic", "oblique")
       */
      function toFontStyle(labelStyle) {
        // Convert label style string to font style
        if (!labelStyle || typeof labelStyle !== "string") {
          return "normal"; // Default to normal if no style is provided
        }

        if (labelStyle.toLowerCase().includes("italic")) {
          return "italic";
        }
        if (labelStyle.toLowerCase().includes("oblique")) {
          return "oblique";
        }

        // default to normal if no specific style is found
        return "normal";
      }

      /**
       * Converts label weight string to a valid font weight
       * @param {string} labelWeight - The label weight string (e.g., "bold", "bolder", "lighter")
       * @returns {string} The corresponding font weight ("normal", "bold", "bolder", "lighter")
       */
      function toFontWeight(labelWeight) {
        // Convert label style string to font weight
        if (!labelWeight || typeof labelWeight !== "string") {
          return "normal"; // Default to normal if no style is provided
        }

        if (labelWeight.toLowerCase().includes("bold")) {
          return "bold";
        }
        if (labelWeight.toLowerCase().includes("bolder")) {
          return "bolder";
        }
        if (labelWeight.toLowerCase().includes("lighter")) {
          return "lighter";
        }

        // default to normal if no specific weight is found
        return "normal";
      }

      /**
       * Converts a hexadecimal color string to RGB values
       * Used for processing label color settings from the UI
       * @param {string} hex - Hexadecimal color string (e.g., "#FF0000")
       * @returns {Object|null} RGB object with r, g, b properties or null if invalid
       */
      function hexToRgb(hex) {
        // Convert hex color to RGB using regex pattern matching
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }

      /**
       * Converts a hexadecimal color string to RGBA values
       * @param {string} hex - Hexadecimal color string (e.g., "#FF0000")
       * @param {number} a - Alpha value (0-1)
       * @returns {Array|null} Array with r, g, b, a values or null if invalid
       */
      function hexToRgba(hex, a) {
        const hexWithoutHash = hex.replace("#", "");

        const r = parseInt(hexWithoutHash.substring(0, 2), 16);
        const g = parseInt(hexWithoutHash.substring(2, 4), 16);
        const b = parseInt(hexWithoutHash.substring(4, 6), 16);

        return [r, g, b, a];
      }

      /**
       * Builds the query URL based on the current UI settings
       * This function constructs the URL for querying the feature layer (or MSL) with LOD, time, and spatial filters
       * @returns {string} The constructed query URL
       */
      function buildQueryUrlFromUI() {
        let timeParam = "";
        if (_replay) {
          const start = _layerTimeExtent.startTime.getTime();
          const end = _layerTimeExtent.endTime.getTime();
          timeParam = "&time=" + start + "," + end;
        } else if (_live) {
          const now = new Date().getTime();
          timeParam = "&time=null," + now;
        }

        let lod = dojo.byId("lod").value;
        let lodGeometryAggregationType = dojo.byId("lodGeometryAggregationType").value;
        const lodType = dojo.byId("lodType").value;
        if (dojo.byId("autoOffSet").checked === true) {
          if (lodType === "flatHexagon" || lodType === "pointyHexagon" || lodType === "square" || lodType === 'geotile') {
            lod = (parseInt(lod) + 5).toString();
          } else if (lodType === "flatTriangle" || lodType === "pointyTriangle") {
            lod = (parseInt(lod) + 4).toString();
          } else if (lodType === 'h3') {
            lod = (parseInt(lod) + 0).toString();
          }
        }

        // Build the query URL
        let url = dojo.byId("inputUrl").value;
        const outSR = _currentMapSR;
        url += "/query?lod=" + lod + "&lodType=" + lodType + "&outSR=" + outSR;
        url += "&lodGeometryAggregationType=" + lodGeometryAggregationType;
        if (dojo.byId("useLodSR") && dojo.byId("useLodSR").checked === true) {
          const lodSR = dijit.byId("lodSR").value;
          url += "&lodSR=" + lodSR;
        }
        url +=  "&returnGeometry=true" + timeParam;


        // TODO - for now, add the spatial filter to the query, only for point geometry layers
        if (_layerInfo && _layerInfo.geometryType && _layerInfo.geometryType === "esriGeometryPoint") {
          const ext = encodeURIComponent(JSON.stringify(_map.extent.toJson()));
          url += "&geometryType=esriGeometryEnvelope&geometry=" + ext;
        }

        url += "&f=pjson";

        if (dojo.byId("useStats").checked === true) {
          const outStatisticsObj = [ {
            "statisticType": dijit.byId("statType").value,
            "onStatisticField": dijit.byId("statField").value,
            "outStatisticFieldName": dijit.byId("statField").value + "_" + dijit.byId("statType").value
          } ];
          const outStatisticsStr = JSON.stringify(outStatisticsObj);
          url += "&outStatistics=" + encodeURIComponent(outStatisticsStr);
        }

        //console.log(url);
        return url;
      }

      /**
       * Toggles the visibility of the aggregation renderer controls
       */
      function toggleUseAggregationRenderer() {
        if (dojo.byId("useAggregationRenderer").checked === true) {
          dojo.byId("aggregationRendererControls").style.display = "block";
        } else {
          dojo.byId("aggregationRendererControls").style.display = "none";
        }

        updateRendererFromUI();
      }

      /**
       * Updates the layer renderer and label based on UI changes
       * This function is called when label-related UI controls are changed
       */
      function updateRendererFromUI() {
        const aggregationLayer = _map.getLayer("aggregations");
        if (!aggregationLayer) {
          console.log("Aggregation layer not found.");
          return;
        }

        // Create and set the bins renderer
        const renderer = dojo.byId("useAggregationRenderer").checked === true ? createAggregationRenderer() : createClassBreakRenderer();
        aggregationLayer.setRenderer(renderer);

        // Create and set the bin labels (if renderLabels is checked)
        if (dojo.byId("renderLabels") && dojo.byId("renderLabels").checked === true) {
          const labelClass = createLabelClass();
          aggregationLayer.setLabelingInfo([labelClass]);
        } else {
          aggregationLayer.setLabelingInfo([]);
        }

        aggregationLayer.refresh();
      }

      /**
       * Updates the aggregation layer based on UI changes
       * This function is called when any UI control that affects the layer is changed
       * @param {boolean} setMapExtent - Whether to set the map extent after updating the layer
       */
      function updateLayerFromUIChange(setMapExtent) {
        // Use current map spatial reference or LOD SR if enabled
        const outputSR = _currentMapSR;
        const sr = new SpatialReference(parseInt(outputSR));
        const mapSR = new SpatialReference(_map.spatialReference.wkid);

        const url = buildQueryUrlFromUI();
        const request = esriRequest({
          "url": url,
          "handleAs": "json",
          "callbackParamName": "callback"
        });
        request.then(
          function (response) {
            // Defensive: ensure features is always an array
            response.features = Array.isArray(response.features) ? response.features : [];

            const aggregationsLayer = _map.getLayer("aggregations");
            const heatmapLayer = _map.getLayer("heatmap");
            if (!aggregationsLayer || !heatmapLayer)
              return;

            const weightsArray = [];

            // If the output SR is different from map SR, we need to project geometries
            if (parseInt(outputSR) !== _map.spatialReference.wkid) {
              // Project all geometries to map's spatial reference
              const geometriesToProject = [];
              array.forEach(response.features, function(feature) {
                if (feature && feature.geometry) {
                  feature.geometry.spatialReference = sr.toJson();
                  geometriesToProject.push(new Polygon(feature.geometry));
                }
              });

              if (geometriesToProject.length > 0) {
                const projectTask = _gs.project(geometriesToProject, mapSR);
                projectTask.then(function(projectedGeometries) {
                  processProjectedFeatures(response.features, projectedGeometries, weightsArray, setMapExtent);
                }, function(error) {
                  console.log("Error projecting geometries:", error);
                  // Fallback: process without projection
                  processFeatures(response.features, weightsArray, setMapExtent);
                });
              }
            } else {
              // No projection needed
              processFeatures(response.features, weightsArray, setMapExtent);
            }
          },
          function (error) {
            console.log("Error querying the aggregations: ", error.message);
          });
      }

      /**
       * Processes projected features and updates the layers with graphics
       * This function is called after geometries are projected to the map's spatial reference
       * This function creates graphics from the projected geometries and updates the layers with them
       * It also calculates weights based on the selected statistics field and type
       * If heatmap is enabled, it uses the centroid of the geometry
       * If statistics are used, it retrieves the weight from the feature attributes
       * If not, it uses the "Count" attribute as the weight
       * @param {Array} features - The array of features to process
       * @param {Array} projectedGeometries - The array of projected geometries corresponding to the features
       * @param {Array} weightsArray - The array to store weights for each feature
       * @param {boolean} setMapExtent - Whether to set the map extent after updating the layer
       */
      function processProjectedFeatures(features, projectedGeometries, weightsArray, setMapExtent) {
        let newFeatures = Array.isArray(features) ? features : [];

        const graphics = array.map(newFeatures, function (feature, i) {
          let geometry = projectedGeometries[i];

          if (dojo.byId("heatmap").checked === true) {
            geometry = geometry.getCentroid();
          }

          let weight = 0;
          if (dojo.byId("useStats").checked === true) {
            let weightFieldName = dijit.byId("statField").value + "_" + dijit.byId("statType").value;
            weight = feature.attributes[weightFieldName];
          } else {
            weight = feature.attributes["Count"];
          }
          feature.attributes["Weight"] = number.round(weight, 2);
          weightsArray.push(weight);

          const graphic = new Graphic(geometry, null, feature.attributes, null);
          return graphic;
        });

        updateLayersWithGraphics(graphics, weightsArray, setMapExtent);
      }

      function processFeatures(features, weightsArray, setMapExtent) {
        let newFeatures = Array.isArray(features) ? features : [];
        const mapSR = new SpatialReference(_map.spatialReference.wkid);

        // create features (graphics) from the response features
        const graphics = array.map(newFeatures, function (feature, i) {
            // Ensure the geometry has the correct spatial reference that matches the map
            if (feature && feature.geometry) {
              // Set the spatial reference to match the map's spatial reference
              feature.geometry['spatialReference'] = mapSR.toJson();
            }

            // create the polygon
            let geometry = new Polygon(feature.geometry);

            if (dojo.byId("heatmap").checked === true) {
              geometry = geometry.getCentroid();
            }

            let weight = 0;
            if (dojo.byId("useStats").checked === true) {
              const weightFieldName = dijit.byId("statField").value + "_" + dijit.byId("statType").value;
              weight = feature.attributes[weightFieldName];
            } else {
              weight = feature.attributes["Count"];
            }
            feature.attributes["Weight"] = number.round(weight, 2);
            weightsArray.push(weight);

            const graphic = new Graphic(geometry, null, feature.attributes, null);
            return graphic;
        });

        updateLayersWithGraphics(graphics, weightsArray, setMapExtent);
      }

      /**
       * Updates the aggregations and heatmap layers with the provided graphics
       * This function is called after querying the feature layer and processing the features
       * This function updates the selected layer (heatmap or aggregations) with the new graphics
       * It also adjusts the renderer based on the selected layer and updates the map extent if needed
       * If the heatmap layer is selected, it sets the blur radius from the UI control
       * @param {Array} graphics - The array of graphics to update the layers with
       * @param {Array} weightsArray - The array of weights corresponding to the graphics
       * @param {boolean} setMapExtent - Whether to set the map extent after updating the layer
       */
      function updateLayersWithGraphics(graphics, weightsArray, setMapExtent) {
        const aggregationsLayer = _map.getLayer("aggregations");
        const heatmapLayer = _map.getLayer("heatmap");

        // add features to the respective selected layer and adjust renderer
        let selectedLayer = null;
        let otherLayer = null;
        if (dojo.byId("heatmap").checked === true) {
          selectedLayer = heatmapLayer;
          otherLayer = aggregationsLayer;
          heatmapLayer.renderer.setBlurRadius(dojo.byId("blurRadius").value);
        } else {
          selectedLayer = aggregationsLayer;
          otherLayer = heatmapLayer;

          // calculate min and max weight values to adjust heatmap renderer
          _minValue = Math.min.apply(null, weightsArray);
          _maxValue = Math.max.apply(null, weightsArray);
          aggregationsLayer.renderer.normalizationTotal = _maxValue;
        }

        // update features layer with new features (graphics)
        otherLayer.setVisibility(false);
        selectedLayer.clear();
        selectedLayer.setVisibility(true);
        selectedLayer.applyEdits(graphics, null, null)
          .then(function () {
            if (setMapExtent && graphics.length > 0) {
              const layerExtent = graphicsUtils.graphicsExtent(graphics);
              if (layerExtent)
                _map.setExtent(layerExtent.expand(1.0));
            }
            selectedLayer.refresh();
          });
      }

      //#############################################################################################
      // Other Functions
      //#############################################################################################

      /**
       * Initializes (init & update including labels) the time slider for the map
       */
      function initTimeSlider() {
        _timeSlider = new TimeSlider({
          style: "width: 100%;"
        }, dom.byId("timeSlider"));
        _map.setTimeSlider(_timeSlider);
        _timeSlider.setThumbCount(2);
        _timeSlider.createTimeStopsByCount(_layerTimeExtent, 21);
        _timeSlider.setThumbIndexes([0, 21]);
        _timeSlider.setThumbMovingRate(2000);
        _timeSlider.startup();
        _timeSlider.on("time-extent-change", function () {
          if (!_ignoreChangeEvent) {
            _layerTimeExtent = _timeSlider.getCurrentTimeExtent();
            updateLayerFromUIChange();
          };
        });
        // add labels for every other time stop
        const labels = createLabels();
        _timeSlider.setLabels(labels);
      }

      /**
       * Updates the time slider based on the current layer time extent
       */
      function updateTimeSlider() {
        queryLayerTimeExtent();
        setTimeout(function () {
          _timeSlider.createTimeStopsByCount(_layerTimeExtent, 21);
          _timeSlider.setThumbIndexes([0, 21]);
          _timeSlider.startup();
          _map.setTimeSlider(_timeSlider);
          // add labels for every other time stop
          const labels = createLabels();
          _timeSlider.setLabels(labels);
          domStyle.set(dom.byId('timeSlider'), "display", 'block');
          updateLayerFromUIChange();
          _ignoreChangeEvent = false;
        }, 1000);
      }

      /**
       * Creates labels for the time slider based on the time stops
       * This function generates labels for every other time stop in the time slider
       * It formats the date and time for display
       * @returns {Array} An array of formatted labels for the time slider
       */
      function createLabels() {
        const labels = array.map(_timeSlider.timeStops, function (timeStop, i) {
          let hours;
          let minutes;
          let seconds;

          if (i % 2 === 0) {
            if (timeStop.getHours() < 10) {
              hours = "0" + timeStop.getHours();
            } else {
              hours = timeStop.getHours();
            };
            if (timeStop.getMinutes() < 10) {
              minutes = "0" + timeStop.getMinutes();
            } else {
              minutes = timeStop.getMinutes();
            };
            if (timeStop.getSeconds() < 10) {
              seconds = "0" + timeStop.getSeconds();
            } else {
              seconds = timeStop.getSeconds();
            };
            const month = timeStop.getMonth() + 1;
            const day = timeStop.getDate();
            //return hours + ":" + minutes;
            return month + "/" + day + "<br>" + hours + ":" + minutes + ":" + seconds;
          } else {
            return "";
          }
        });
        return labels;
      }

      /**
       * Starts the auto-update process for the layer
       * This function sets a timeout to update the layer every 2 seconds
       * It checks if the live mode is enabled before continuing
       */
      function autoUpdate() {
        setTimeout(function () {
          updateLayerFromUIChange();
          if (_live) {
            autoUpdate();
          }
        }, 2000);
      }

      /**
       * Handles the change event for the basemap dropdown
       * This function updates the map's basemap layer based on the selected URL from the dropdown
       * It removes the existing basemap layer if it exists and adds a new one
       */
      function onSelectedBasemapChanged() {
        // Get the selected basemap URL from the dropdown
        const basemapUrl = dom.byId("basemapUrl").value;
        console.log("Selected basemap URL: ", basemapUrl);

        // Check if the map object is initialized
        if (!_map) {
          console.error("Map object is not initialized.");
          return;
        }

        // Remove the existing basemap layer if it exists
        const basemapLayer = _map.getLayer("basemap");
        if (basemapLayer) {
          console.log("Removing existing basemap layer.");
          _map.removeLayer(basemapLayer);
        }

        // Add the new basemap layer
        let newBasemapLayer;
        if (_isBasemapTiled) {
          newBasemapLayer = new ArcGISTiledMapServiceLayer(basemapUrl, { id: "basemap" });
        } else {
          newBasemapLayer = new ArcGISDynamicMapServiceLayer(basemapUrl, { id: "basemap", opacity: 1.0 });
        }
        _map.addLayer(newBasemapLayer);

        console.log("Basemap updated to: " + basemapUrl);
      }


      //#############################################################################################
      // Initialization
      //#############################################################################################

      // Initialize the map and layers when the DOM is ready
      require(["dojo/domReady!"], function() {
        const basemapDropdown = dom.byId("basemapUrl");
        if (basemapDropdown) {
          // Attach the event listener to the basemap dropdown
          on(basemapDropdown, "change", onSelectedBasemapChanged);
        } else {
          console.warn("Element with ID 'basemapUrl' not found in the DOM.");
        }
      });

      on(dojo.byId("labelOpacity"), "input", function() {
        const slider = dojo.byId("labelOpacity");
        slider.title = Math.round(slider.value * 255);
      });
    });
  </script>
</head>

<body class="flat">
  <div id="map"></div>
  <div id="timeSlider"></div>
  <div class="collapser">
    <i id="collapserIcon" class="flat-chevron-right"></i>
    <i id="expanderIcon" class="flat-chevron-left"></i>
  </div>
  <div id="controls">
    <!-- [Section 1] Layers -->
    <section id="layersSection">
      <div class="config-header">
        <h2>Layers</h2>
        <div class="header-actions-group">
          <a href="#" id="layersToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>

      <div class="config-content">
        <!-- Layer -->
        <div class="input-row">
          <input type="text" id="inputUrl" value="https://storm.esri.com:6443/arcgis/rest/services/faa/MapServer/0" />
          <input type="button" class="button" id="setLayerButton" value="Set Layer" />
        </div>

        <!-- Select Basemap -->
        <div title="Select Base Map" class="input-group input-group-full">
          <select id="basemapUrl" name="basemapUrl" style="width: 120px;">
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Topo_Map/MapServer">Topographic</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer">Streets</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer">National Geographic</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Canvas/World_Light_Gray_Base/MapServer">Light Gray Canvas</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Canvas/World_Dark_Gray_Base/MapServer">Dark Gray Canvas</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer">Imagery</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Terrain_Base/MapServer">Terrain</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Shaded_Relief/MapServer">Shaded Relief</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Transportation/MapServer">Transportation</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Reference_Overlay/MapServer">World Reference</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer">Oceans</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/USA_Topo_Maps/MapServer">USA Topo Maps</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Specialty/World_Navigation_Charts/MapServer">Navigation Charts</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Boundaries_and_Places/MapServer">Boundaries and Places</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer">Boundaries and Places Alternate</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer">USGS National Map</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer">USGS Imagery</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer">USGS Imagery with Labels</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSHydroCached/MapServer">USGS Hydro</option>
          </select>
          <label for="basemapUrl">BaseMap</label>
        </div>

        <!-- Select Map SR -->
        <div title="Select Map Spatial Reference" class="input-group input-group-full">
          <select name="spatialReferenceSelect" data-dojo-type="dijit/form/Select" id="spatialReferenceSelect" style="width: 200px;">
            <option value="102003">102003 (Albers)</option>
            <option value="102100" selected="selected">102100 (Web Mercator)</option>
            <option value="4326">4326 (WGS84)</option>
            <option value="54030">54030 (Robinson)</option>
            <option value="26911">26911 (NAD83 / UTM zone 11N)</option>
            <option value="27700">27700 (British National Grid)</option>
            <option value="2243">2243 (Idaho West, State Plane)</option>
            <option value="2244">2244 (Indiana East, State Plane)</option>
            <option value="2248">2248 (Maryland, State Plane)</option>
            <option value="3995">3995 (Arctic Polar Stereographic)</option>
            <option value="2271">2271 (NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="2272">2272 (NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
            <option value="3363">3363 (NAD_1983_HARN_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="3365">3365 (NAD_1983_HARN_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
          </select>
          <label for="spatialReferenceSelect">Map SR</label>
        </div>
      </div>
    </section>

    <!-- [Section 2] Aggregation Settings -->
    <section id="aggSettingsSection">
      <div class="config-header">
        <h2>Aggregation Settings</h2>
        <div class="header-actions-group">
          <a href="#" id="aggSettingsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content" style="padding-bottom: 5px;">
        <div class="input-group input-group-full">
          <input type="number" id="lod" value="3" />
          <label for="lod">LOD</label>
        </div>
        <div class="input-group input-group-full input-group-checkbox-full">
          <label for="autoOffSet">Auto offset</label>
          <input type="checkbox"
            id="autoOffSet"
            checked="true"
            title="Auto Offset LOD based on the LOD type:&#10; GeoHash: 0&#10; Geotile: 5&#10; H3: 0&#10; Square: 5&#10; Flat Hexagon: 5&#10; Pointy Hexagon: 5&#10; Flat Triangle: 4&#10; Pointy Triangle: 4"/>
        </div>
      </div>
    </section>

    <!-- [Section 3] Aggregation Style -->
    <section id="aggStyleSection">
      <div class="config-header">
        <h2>Aggregation Style</h2>
        <div class="header-actions-group">
          <a href="#" id="aggStyleToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div title="LOD Aggregation Type" class="config-content" style="padding-bottom: 5px;">
        <div class="input-group input-group-full">
          <select name="lodType" id="lodType" style="width: 120px;">
            <option value="geohash" selected="selected">GeoHash</option>
            <option value="geotile">GeoTile</option>
            <option value="h3">H3</option>
            <option value="square">Square</option>
            <option value="flatHexagon">Flat Hexagon</option>
            <option value="pointyHexagon">Pointy Hexagon</option>
            <option value="flatTriangle">Flat Triangle</option>
            <option value="pointyTriangle">Pointy Triangle</option>
          </select>
          <label for="lodType">LOD Type</label>
        </div>
        <div title="LOD Geometry Aggregation Type" class="input-group input-group-full">
          <select name="lodGeometryAggregationType" id="lodGeometryAggregationType" style="width: 120px;">
            <option value="centroid" selected="selected">Centroid</option>
            <option value="shape">Shape</option>
          </select>
          <label for="lodGeometryAggregationType">Geometry</label>
        </div>
      </div>
      <div title="Leave unchecked to auto select the LOD Spatial Reference" class="config-content" style="padding-top: 0;">
        <label for="useLodSR">LOD SR</label>
        <input type="checkbox" id="useLodSR" />
        <select name="lodSR" data-dojo-type="dijit/form/Select" id="lodSR" style="width: 200px;">
          <option value="102003">102003 (Albers)</option>
          <option value="102100" selected="selected">102100 (Web Mercator)</option>
          <option value="4326">4326 (WGS84)</option>
          <option value="54030">54030 (Robinson)</option>
          <option value="26911">26911 (NAD83 / UTM zone 11N)</option>
          <option value="27700">27700 (British National Grid)</option>
          <option value="2243">2243 (Idaho West, State Plane)</option>
          <option value="2244">2244 (Indiana East, State Plane)</option>
          <option value="2248">2248 (Maryland, State Plane)</option>
          <option value="3995">3995 (Arctic Polar Stereographic)</option>
          <option value="2271">2271 (NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
          <option value="2272">2272 (NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
          <option value="3363">3363 (NAD_1983_HARN_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
          <option value="3365">3365 (NAD_1983_HARN_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
        </select>
      </div>
    </section>

    <!-- [Section 4] Aggregation Bins Section -->
    <section id="aggBinsSection">
      <div class="config-header">
        <h2>Aggregation Bins</h2>
        <div class="header-actions-group">
          <input type="checkbox" id="useAggregationRenderer" title="Use Aggregation Renderer"/>
          <a href="#" id="aggBinsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div id="aggregationRendererControls" style="display: none;">
        <div class="config-content" style="padding-bottom: 0px;">
          <div class="input-row input-row-header-labeled">
            <label>Min</label>
            <label>Max</label>
          </div>
          <div class="input-row input-row-header">
            <label>Fill Color</label>
            <input title="Min Fill Color" type="color" value="#ff0000" id="minColor" style="width: 20%;"/>
            <input title="Max Fill Color" type="color" value="#ff0000" id="maxColor" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Fill Opacity</label>
            <input title="Min Fill Opacity" type="number" min="0" max="255" id="minColorA" value="0" style="width: 20%;"/>
            <input title="Max Fill Opacity" type="number" min="0" max="255" id="maxColorA" value="255" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Outline Color</label>
            <input title="Min Outline Color" type="color" value="#000000" id="minOutlineColor" style="width: 20%;"/>
            <input title="Max Outline Color" type="color" value="#000000" id="maxOutlineColor" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Outline Opacity</label>
            <input title="Min Outline Opacity" type="number" min="0" max="255" id="minOutlineColorA" value="100" style="width: 20%;"/>
            <input title="Max Outline Opacity" type="number" min="0" max="255" id="maxOutlineColorA" value="100" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Outline Width</label>
            <input title="Min Outline Width" type="number" min="0" id="minOutlineWidth" value="0.5" style="width: 20%;"/>
            <input title="Max Outline Width" type="number" min="0" id="maxOutlineWidth" value="0.5" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" id="ovalAttrSection" style="display: none;">
            <label>Size</label>
            <input title="Min Size in Precent" type="number" min="0" max="100" placeholder="min" id="minSize" value="100" style="width: 20%;"/>
            <input title="Max Size in Precent" type="number" min="0" max="100" placeholder="max" id="maxSize" value="100" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" style="display: none;">
            <label>Range</label>
            <input title="Min Value. Leave empty to auto-calculate dynamically based on actual values in the current extent." type="number" id="minValue" value="" placeholder="min" style="width: 20%;"/>
            <input title="Max Value. Leave empty to auto-calculate dynamically based on actual values in the current extent." type="number" id="maxValue" value="" placeholder="max" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" style="justify-content: flex-start;">
            <label for="classBreaksCount">Class Breaks</label>
            <input type="number" id="classBreaksCount" value="10" min="2"/>
          </div>
        </div>
      </div>
      <div class="config-content">
        <div class="input-row input-row-header" style="justify-content: flex-start;">
          <label for="heatmap">Heatmap</label>
          <input type="checkbox" id="heatmap" />
        </div>
        <div id="radius" class="input-row input-row-header" style="justify-content:flex-start; display:none;">
          <label for="blurRadius">Blur Radius</label>
          <input type="number" id="blurRadius" value="10" style="width: 40px;" />
        </div>
        <div class="input-row input-row-header" style="justify-content: flex-start;">
          <label for="useStats">Statistics</label>
          <input type="checkbox" id="useStats" style="top:4px;"/>
        </div>
        <div class="input-row input-row-header">
          <label></label>
          <select name="statField" data-dojo-type="dijit/form/Select" data-dojo-attach-point="statField"
            id="statField"
            style="width: 250px; margin-top:3px; display:none; float:left;">
          </select>
        </div>
        <div class="input-row input-row-header">
          <label></label>
          <select name="statType" data-dojo-type="dijit/form/Select" data-dojo-attach-point="statType"
            id="statType"
            style="width: 250px; margin-top:3px; display:none; float:left;">
          </select>
        </div>
      </div>
    </section>

    <!-- [Section 5] Aggregation Labels Section -->
    <section id="aggLabelsMainSection">
      <div class="config-header">
        <h2>Aggregation Labels</h2>
        <div class="header-actions-group">
          <input type="checkbox" id="renderLabels" checked="true" title="Render Labels"/>
          <a href="#" id="aggLabelsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>

      <div id="aggLabelsSection" class="config-content">

        <!-- Label Font -->
        <div class="input-group input-group-full">
          <select name="labelFont" data-dojo-type="dijit/form/Select" id="labelFont" style="width: 99%;">
            <option value="arial" selected="selected">Arial</option>
            <option value="arial black">Arial Black</option>
            <option value="arial narrow">Arial Narrow</option>
            <option value="brush script mt">Brush Script MT</option>
            <option value="comic sans ms">Comic Sans MS</option>
            <option value="courier">Courier</option>
            <option value="courier new">Courier New</option>
            <option value="cursive">Cursive</option>  
            <option value="custom">Custom</option>
            <option value="fantasy">Fantasy</option> 
            <option value="garamond">Garamond</option>
            <option value="georgia">Georgia</option>
            <option value="helvetica">Helvetica</option>
            <option value="impact">Impact</option>
            <option value="lucida console">Lucida Console</option>
            <option value="lucida grande">Lucida Grande</option>
            <option value="lucida sans unicode">Lucida Sans Unicode</option>
            <option value="monospace">Monospace</option>
            <option value="palatino">Palatino</option>
            <option value="segoe ui">Segoe UI</option>
            <option value="sans-serif">Sans Serif</option>
            <option value="serif">Serif</option>
            <option value="symbol">Symbol</option>
            <option value="tahoma">Tahoma</option>
            <option value="times">Times</option>
            <option value="times new roman">Times New Roman</option>
            <option value="trebuchet ms">Trebuchet MS</option>
            <option value="verdana">Verdana</option>
            <option value="webdings">Webdings</option>
            <option value="wingdings">Wingdings</option>
            <option value="zapf dingbats">Zapf Dingbats</option>
          </select>
          <label for="labelFont">Font</label>
        </div>

        <!-- Label Style -->
        <div class="input-group input-group-full">
          <select name="labelStyle" data-dojo-type="dijit/form/Select" id="labelStyle" style="width: 99%;">
            <option value="normal">Normal</option>
            <option value="italic">Italic</option>
            <option value="oblique">Oblique</option>
          </select>
          <label for="labelStyle">Style</label>
        </div>

        <!-- Label Weight -->
        <div class="input-group input-group-full">
          <select name="labelWeight" data-dojo-type="dijit/form/Select" id="labelWeight" style="width: 99%;">
            <option value="normal">Normal</option>
            <option value="bold">Bold</option>
            <option value="bolder">Bolder</option>
            <option value="lighter">Lighter</option>
          </select>
          <label for="labelStyle">Weight</label>
        </div>

        <!-- Label Size -->
        <div class="input-group">
          <input type="number" id="labelSize" value="9" style="width: 60px;"/>
          <label for="labelSize">Size</label>
        </div>
        <!-- Label Color -->
        <div class="input-group">
          <input type="color" value="#000000" id="labelColor" style="width: 60px;"/>
          <label for="labelColor">Color</label>
        </div>
        <!-- Label Opacity -->
        <div class="input-group">
          <!--input type="number" min="0" max="255" id="labelColorA" value="255" style="width: 60px;"/-->
          <input type="range" id="labelOpacity" min="0" max="1" step="0.02" value="1" style="width: 100px;" />
          <label for="labelOpacity">Opacity</label>
        </div>

      </div>
    </section>

    <!-- [Section 6] Streaming Mode Section -->
    <section id="streamingModeSection">
      <div class="config-header">
        <h2>Streaming Mode</h2>
        <div class="header-actions-group">
          <a href="#" id="streamingModeToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content">
        <div class="input-group">
          <select name="aggStreamMode" id="refreshMode" style="width: 120px;">
            <option value="manual">Manual</option>
            <option value="live">Live</option>
            <option value="replay">Replay</option>
          </select>
          <label for="refreshMode">Mode</label>
        </div>
      </div>
    </section>

  </div>
</body>

</html>
