<!--
  Copyright 1995-2017 Esri

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

  For additional information, contact:
  Environmental Systems Research Institute, Inc.
  Attn: Contracts Dept
  380 New York Street
  Redlands, California, USA 92373

  email: contracts@esri.com
-->

<!DOCTYPE html>

<html>

<head lang="en">
  <meta charset="UTF-8">

  <title>Aggregation Viewer - Client Side Feature Layer</title>

  <link rel="stylesheet" href="https://js.arcgis.com/3.46/esri/css/esri.css">
  <link rel="stylesheet" href="./featureServiceViewerStyles.css">

  <script src="https://use.fontawesome.com/9482a0b1d1.js"></script>
  <script src="https://js.arcgis.com/3.46/"></script>
  <script>
    require([
      "dojo/parser",
      "dojo/dom",
      "dojo/dom-style",
      "dojo/dom-class",
      "dojo/on",
      "dojo/json",
      "dojo/_base/array",
      "dojo/query",
      "dojo/number",

      "esri/map",
      "esri/graphic",
      "esri/SpatialReference",
      "esri/Color",
      "esri/request",
      "esri/geometry/webMercatorUtils",
      "esri/geometry/Extent",
      "esri/tasks/GeometryService",
      "esri/InfoTemplate",
      "esri/TimeExtent",
      "esri/graphicsUtils",

      "esri/IdentityManager",

      "esri/layers/FeatureLayer",
      "esri/layers/LabelClass",
      "esri/layers/ArcGISDynamicMapServiceLayer",
      "esri/layers/ArcGISTiledMapServiceLayer",

      "esri/symbols/SimpleLineSymbol",
      "esri/symbols/SimpleFillSymbol",
      "esri/symbols/TextSymbol",
      "esri/geometry/Polygon",

      "esri/dijit/TimeSlider",

      "esri/renderers/HeatmapRenderer",
      "esri/renderers/ClassBreaksRenderer",

      "dijit/layout/BorderContainer",
      "dijit/layout/ContentPane",
      "dijit/TitlePane",
      "dijit/TooltipDialog",
      "dijit/form/DropDownButton",
      "dijit/form/Select",

      "dojo/query!css2",
      "dojo/domReady!"
    ], function (
      parser, dom, domStyle, domClass, on, JSON, array, domQuery, number,
      Map, Graphic, SpatialReference, Color, esriRequest, webMercatorUtils, Extent, GeometryService, InfoTemplate, TimeExtent, graphicsUtils,
      IdentityManager,
      FeatureLayer, LabelClass, ArcGISDynamicMapServiceLayer, ArcGISTiledMapServiceLayer,
      SimpleLineSymbol, SimpleFillSymbol, TextSymbol, Polygon,
      TimeSlider,
      HeatmapRenderer, ClassBreaksRenderer,
      BorderContainer, ContentPane, TitlePane, TooltipDialog, DropDownButton, Select) {

      parser.parse();

      // ### global variables ###
      var _map;
      var _layerTimeExtent;
      var _replay = false;
      var _live = false;
      var _startTimeSlider = true;
      var _minValue;
      var _maxValue;
      var _ignoreChangeEvent = false;
      var _layerInfo;
      var _binRendererProps = {};
      
      // ### Spatial Reference variables ###
      // These variables manage coordinate system transformations and spatial reference handling
      var _defaultWkid = 102100; // Web Mercator - default coordinate system
      var _wkid = 102100;         // Current working coordinate system ID
      var _currentMapSR = 102100; // Current map spatial reference system
      
      // ### Geometry Service for spatial reference transformations ###
      var _gs = new GeometryService("https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer");

      // Define _isBasemapTiled with a default value
      var _isBasemapTiled = true; // Set to true if tiled basemaps are the default, otherwise false

      //#############################################################################################
      // Map Related functions
      //#############################################################################################

      esri.config.defaults.io.corsEnabledServers.push('http://storm.esri.com');
      esri.config.defaults.io.corsEnabledServers.push('http://storm.esri.com:6080');
      esri.config.defaults.io.corsEnabledServers.push('https://storm.esri.com:6443');
      esri.config.defaults.io.corsEnabledServers.push('http://localhost:9000');

      // ### Initialize map with default extent ###
      var initMapExtent = new Extent({
        "xmin": -20037508.342787,
        "ymin": -20037508.342787,
        "xmax": 20037508.342787,
        "ymax": 20037508.342787,
        "spatialReference": {"wkid": _defaultWkid}
      });

      // Build initial map with the default extent
      buildMap(initMapExtent);

      /**
       * Builds or rebuilds the map with the specified extent and current spatial reference
       * This function destroys any existing map and creates a new one with proper spatial reference
       * @param {Extent} mapExtent - The extent to set for the new map
       */
      function buildMap(mapExtent) {

        if (_map) {
          // Destroy existing map if it exists
          _map.removeAllLayers();
          _map.destroy();
          _map = null;
          console.log("Destroyed previous map instance for spatial reference change");
        }

        // Create new map with the specified extent
        _map = new Map("map", {
          wrapAround180: true,
          extent: mapExtent,
          showLabels: true,
          showAttribution: false,
          sliderStyle: "small"
        });

        _map.on("load", function () {
          console.log("Map loaded successfully.");
          setFeatureLayers();
        });

        // Attach extent change handler
        attachMapExtentChangeHandler();

        // Add the basemap
        var basemapUrl = dom.byId("basemapUrl").value;
        var basemapLayer;
        basemapLayer = new ArcGISDynamicMapServiceLayer(basemapUrl, {
          "showAttribution": false,
          "opacity": 1.0
        });
        _map.addLayers([basemapLayer]);

        // only the first map built is tiled
        _isBasemapTiled = false;

        // Update current map SR display
        dom.byId("currentMapSR").value = _wkid;
      }

      // ### Issue new query on extent-change if live mode is disabled ###
      // Note: This event handler will be re-attached when map is rebuilt
      function attachMapExtentChangeHandler() {
        _map.on("extent-change", function (evt) {
          if (_map.getLayer("aggregations") && !_ignoreChangeEvent && !_live) {
            updateLayerFromUIChange();
          }
        });
      }

      //#############################################################################################
      // UI Related functions
      //#############################################################################################

      // ### UI event listener ###
      
      // ### DRY: Reusable section toggle function ###
      function createSectionToggle(sectionId, toggleId, visibilityVar) {
        return function () {
          // toggle section visibility
          if (visibilityVar.value) {
            domClass.add(dojo.byId(sectionId), "section-hidden");
            domClass.replace(domQuery("#" + toggleId + " i")[0], "fa-chevron-down", "fa-chevron-up");
          } else {
            domClass.remove(dojo.byId(sectionId), "section-hidden");
            domClass.replace(domQuery("#" + toggleId + " i")[0], "fa-chevron-up", "fa-chevron-down");
          }
          visibilityVar.value = !visibilityVar.value;
        };
      }

      // ### Section visibility state objects ###
      var layersVisibility = { value: true };
      var aggSettingsVisibility = { value: true };
      var aggStyleVisibility = { value: false };
      var aggBinsVisibility = { value: true };
      var streamingModeVisibility = { value: true };
      var spatialReferenceVisibility = { value: true };
      var lodSRVisibility = { value: true };
      var aggLabelsVisibility = { value: true };

      // ### Section toggle event handlers ###
      on(dojo.byId("layersToggle"), "click", createSectionToggle("layersSection", "layersToggle", layersVisibility));
      on(dojo.byId("aggSettingsToggle"), "click", createSectionToggle("aggSettingsSection", "aggSettingsToggle", aggSettingsVisibility));
      on(dojo.byId("aggStyleToggle"), "click", createSectionToggle("aggStyleSection", "aggStyleToggle", aggStyleVisibility));
      on(dojo.byId("aggBinsToggle"), "click", createSectionToggle("aggBinsSection", "aggBinsToggle", aggBinsVisibility));
      on(dojo.byId("streamingModeToggle"), "click", createSectionToggle("streamingModeSection", "streamingModeToggle", streamingModeVisibility));
      on(dojo.byId("aggLabelsToggle"), "click", createSectionToggle("aggLabelsMainSection", "aggLabelsToggle", aggLabelsVisibility));

      on(dojo.byId("setLayerButton"), "click", setFeatureLayers);
      on(dojo.byId("heatmap"), "change", toggleHeatmap);
      on(dojo.byId("refreshMode"), "change", toggleMode);
      on(dojo.byId("autoOffSet"), "change", toggleRefresh);
      on(dojo.byId("aggStyle"), "change", toggleRefresh);
      on(dojo.byId("aggSubStyle"), "change", toggleRefresh);
      on(dojo.byId("lod"), "change", toggleRefresh);
      on(dojo.byId("blurRadius"), "change", toggleRefresh);
      on(dom.byId("useStats"), "change", toggleStats);

      on(dijit.byId("statField"), "change", statFieldChanged);
      on(dijit.byId("statType"), "change", updateLayerFromUIChange);
      
      // ### Spatial Reference event handlers ###
      on(dijit.byId("spatialReferenceSelect"), "change", onSpatialReferenceChange);

      // ### Aggregation Renderer event handlers ###
      on(dojo.byId("useAggregationRenderer"), "change", toggleUseAggregationRenderer);
      on(dojo.byId("minColor"), "change", updateRendererFromUI);
      on(dojo.byId("maxColor"), "change", updateRendererFromUI);
      on(dojo.byId("minColorA"), "change", updateRendererFromUI);
      on(dojo.byId("maxColorA"), "change", updateRendererFromUI);
      on(dojo.byId("minOutlineColor"), "change", updateRendererFromUI);
      on(dojo.byId("maxOutlineColor"), "change", updateRendererFromUI);
      on(dojo.byId("minOutlineColorA"), "change", updateRendererFromUI);
      on(dojo.byId("maxOutlineColorA"), "change", updateRendererFromUI);
      on(dojo.byId("minOutlineWidth"), "change", updateRendererFromUI);
      on(dojo.byId("maxOutlineWidth"), "change", updateRendererFromUI);
      on(dojo.byId("minSize"), "change", updateRendererFromUI);
      on(dojo.byId("maxSize"), "change", updateRendererFromUI);
      on(dojo.byId("minValue"), "change", updateRendererFromUI);
      on(dojo.byId("maxValue"), "change", updateRendererFromUI);
      on(dojo.byId("classBreaksCount"), "change", updateRendererFromUI);

      // ### Aggregation Labels event handlers ###
      on(dojo.byId("renderLabels"), "change", updateRendererFromUI);
      on(dijit.byId("labelFont"), "change", updateRendererFromUI);
      on(dijit.byId("labelStyle"), "change", updateRendererFromUI);
      on(dijit.byId("labelWeight"), "change", updateRendererFromUI);
      on(dojo.byId("labelSize"), "change", updateRendererFromUI);
      on(dojo.byId("labelColor"), "change", updateRendererFromUI);
      on(dojo.byId("labelOpacity"), "change", updateRendererFromUI);
      
      // ### LOD SR event handlers ###
      on(dijit.byId("lodSpatialReference"), "change", updateLayerFromUIChange);
      on(dojo.byId("useLodSR"), "change", updateLayerFromUIChange);

      on(document.getElementsByClassName("collapser")[0], "click", togglePanel);


      function setFeatureLayers() {

        // Remove existing feature layers
        var aggregationLayer = _map.getLayer("aggregations");
        if (aggregationLayer) {
          _map.removeLayer(aggregationLayer);
        } else {
          console.log("Aggregation layer not found.");
        }

        var heatmapLayer = _map.getLayer("heatmap");
        if (heatmapLayer) {
          _map.removeLayer(heatmapLayer);
        } else {
          console.log("Heatmap layer not found.");
        }

        var aggregationLayer = addAggregationsLayer();
        aggregationLayer.on("load", function () {
          queryLayerTimeExtent();
          addHeatmapLayer();
          updateLayerFromUIChange(true);
        });
      }

      function togglePanel() {
        domClass.toggle(document.getElementsByTagName("body")[0], "panel-collapsed");
      }

      // ### Switch change functions ###

      function toggleMode(evt) {
        //console.log(evt.target.value);
        if (evt.target.value === "manual") {
          _live = false;
          _replay = false;
          domStyle.set(dom.byId('timeSlider'), "display", 'none');
          _map.setTimeSlider(null);
          _map.setTimeExtent(null);
          updateLayerFromUIChange();
        } else if (evt.target.value === "live") {
          _live = true;
          _replay = false;
          autoUpdate();
          domStyle.set(dom.byId('timeSlider'), "display", 'none');
          _map.setTimeSlider(null);
          _map.setTimeExtent(null);
        } else if (evt.target.value === "replay") {
          _live = false;
          _replay = true;
          if (_startTimeSlider) {
            initTimeSlider();
            _startTimeSlider = false;
          } else {
            _ignoreChangeEvent = true;
            updateTimeSlider();
          }
          domStyle.set(dom.byId('timeSlider'), "display", 'block');
        }
      }

      function toggleHeatmap(evt) {
        if (dojo.byId("heatmap").checked === true) {
          dojo.byId("radius").style.display = "inherit";
          var layer = _map.getLayer("heatmap");
          var minIsFinit = isFinite(_minValue);
          var maxIsFinit = isFinite(_maxValue);
          if (!minIsFinit) {
            _minValue = 0;
          }
          if (!maxIsFinit) {
            _maxValue = 1;
          }
          layer.renderer.setMinPixelIntensity(_minValue);
          layer.renderer.setMaxPixelIntensity(_maxValue);
        } else {
          dojo.byId("radius").style.display = "none";
        }
        updateLayerFromUIChange();
      }

      function toggleRefresh(evt) {
        if (!_live) {
          updateLayerFromUIChange();
        }
      }

      function toggleStats(evt) {
        if (evt.target.id === "useStats") {
          if (dojo.byId("useStats").checked === true) {
            dojo.byId("statField").style.display = "block";
            dojo.byId("statType").style.display = "block";
          } else {
            dojo.byId("statField").style.display = "none";
            dojo.byId("statType").style.display = "none";
          }
          updateLayerFromUIChange();
        }
      }

      function statFieldChanged(val) {
        var control = dijit.byId('statField');
        var selectedOption = control.getOptions(val);
        populateStatTypeSelectOptions(selectedOption);
        updateLayerFromUIChange();
      }

      // ### Spatial Reference Functions ###
      /**
       * Handles spatial reference system changes from the dropdown
       * Updates global variables and re-projects map if necessary
       * @param {string|number} newWkid - The new spatial reference WKID
       */
      function onSpatialReferenceChange(newWkid) {
        _wkid = parseInt(newWkid);

        // Check if the map's current spatial reference matches the new one
        if (_map && _map.spatialReference && _wkid === _map.spatialReference.wkid) {
          return; // No need to rebuild the map
        }

        // Update the current map spatial reference
        _currentMapSR = _wkid;

        // Project the map's current extent to the new spatial reference
        projectMapToSR(_wkid);
      }

      /**
       * Projects the current map extent to a new spatial reference system using geometry service
       * @param {number} wkid - The target spatial reference WKID
       */
      function projectMapToSR(wkid) {
        var sr = new SpatialReference(wkid);
        var project = _gs.project([_map.extent], sr);
        project.then(function (result) {
          if (result.length) {
            var newMapExtent = result[0];
            buildMap(newMapExtent); // Rebuild the map with the new extent
            dom.byId("currentMapSR").value = _wkid;
          } else {
            console.log("Projection was successful, but no results were returned.");
          }
        }, function (err) {
          console.log("Project Map to SR failed: ", err);
          // Fallback: build map with default extent for the new spatial reference
          var defaultExtent = new Extent({
            "xmin": -20037508.342787,
            "ymin": -20037508.342787,
            "xmax": 20037508.342787,
            "ymax": 20037508.342787,
            "spatialReference": { "wkid": wkid }
          });
          buildMap(defaultExtent);
          dom.byId("currentMapSR").value = _wkid;
        });
      }


      // ### Aggregation Labels Functions ###
      /**
       * Toggles the visibility of aggregation labels and their control panel
       * @param {Event} evt - The change event from the checkbox
       */
      function toggleLabels(evt) {
        // Toggle label visibility and show/hide label controls
        if (evt.target.id === "renderLabels") {
          if (dojo.byId("renderLabels").checked === true) {
            dojo.byId("aggLabelsSection").style.display = "block";
          } else {
            dojo.byId("aggLabelsSection").style.display = "none";
          }
          updateLayerFromUIChange();
        }
      }

      function populateStatTypeSelectOptions(selectedOption) {
        var statTypeSelect = dijit.byId("statType");
        var prevStatType = statTypeSelect.value;

        // clear statTypeSelect
        statTypeSelect.removeOption(statTypeSelect.getOptions());

        // find the field by name
        var statFieldElement = dijit.byId("statField");
        if (!statFieldElement) {
          console.warn("Element with ID 'statField' not found.");
          return;
        }
        var fieldName = statFieldElement.value;
        var field = null;
        for (i = 0; i < _layerInfo.fields.length; i++) {
          var currentField = _layerInfo.fields[i];
          if (currentField.name === fieldName)
            field = currentField;
        }

        // add the stat type options
        var statTypeOptions = null;
        if (isFieldNumeric(field)) {
          // add all types
          var options = [ {'label':'Average', 'value':'avg'},
                          {'label':'Maximum', 'value':'max'},
                          {'label':'Minimum', 'value':'min'},
                          {'label':'Standard Deviation', 'value':'stddev'},
                          {'label':'Sum', 'value':'sum'},
                          {'label':'Variance', 'value':'var'},
                          {'label':'Count Distinct', 'value':'countdistinct'},
                          {'label':'Count', 'value':'count'} ];
          statTypeSelect.addOption(options);
        } else {
          // add only the count and count distinct types
          var options = [ {'label':'Count Distinct', 'value':'countdistinct'},
                          {'label':'Count', 'value':'count'} ];
          statTypeSelect.addOption(options);
        }

        updateLayerFromUIChange();
      }

      function getLayerInfo() {
        var url = dojo.byId("inputUrl").value;
        var mapServiceInfoDeferred = esri.request({
          url: url,
          content: {
            f: 'json'
          },
          callbackParamName: "callback"
        });
        mapServiceInfoDeferred.then(function (response) {
              _layerInfo = response;
              populateDijitSelectWithLayerFields(dijit.byId('statField'), false);
              statFieldChanged(dijit.byId('statField').value); // to init-populate the stat types control
            }
        );
      }

      function populateDijitSelectWithLayerFields(select, numericOnly) {
        // clear exiting options
        select.removeOption(select.getOptions());

        // populate options based on the _layerInfo.fields array
        var i;
        for (i = 0; i < _layerInfo.fields.length; i++) {
          var field = _layerInfo.fields[i];
          var fieldType = field.type.substring(13);
          var option = {'label': field.name + "&nbsp;&nbsp;" + "<em class='fieldTypeSelect'>" + fieldType + '</em>', 'value': field.name, 'type': field.type };
          if (numericOnly) {
            if (isFieldNumeric(field))
              select.addOption(option);
          } else {
            if (isSupportedStatField(field))
              select.addOption(option);
          }
        }
      }

      function populateSelectWithLayerFields(select, numericOnly) {
        // clear exiting options
        var i;
        for (i = select.options.length - 1; i >= 0; i--) {
          select.remove(i);
        }

        // populate options based on the layerFields array
        var pos = 0;
        for (i = 0; i < layerFields.length; i++) {
          var field = _layerInfo.fields[i];
          if (numericOnly) {
            if (isFieldNumeric(field))
              select.options[pos++] = new Option(field.name, field.name);
          } else {
            if (isSupportedStatField(field))
              select.options[pos++] = new Option(field.name, field.name);
          }
        }
      }

      // field type can be one of the following: "esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeString", "esriFieldTypeDate", "esriFieldTypeOID", "esriFieldTypeGeometry", "esriFieldTypeBlob", "esriFieldTypeRaster", "esriFieldTypeGUID", "esriFieldTypeGlobalID", "esriFieldTypeXML"
      function isFieldNumeric(field) {
          if (!field || !field.type)
            return false;

          return (field.type === "esriFieldTypeSmallInteger" || field.type === "esriFieldTypeInteger" || field.type === "esriFieldTypeSingle" || field.type === "esriFieldTypeDouble" || field.type === "esriFieldTypeOID");
      }

      function isSupportedStatField(field) {
          if (!field || !field.type)
            return false;

          return (field.type !== "esriFieldTypeGeometry" && field.type !== "esriFieldTypeBlob" && field.type !== "esriFieldTypeRaster");
      }

      //#############################################################################################
      // Layer related functions
      //#############################################################################################

      /**
       * Adds a client-side feature layer for aggregations with a predefined feature collection and renderer
       * This layer will be used to display aggregated data on the map
       * @returns {FeatureLayer} The created FeatureLayer instance
       */
      function addAggregationsLayer() {
        var layerDefinition = {
          "geometryType": "esriGeometryPolygon",
          "fields": [
            {
              "name": "objectid",
              "type": "esriFieldTypeInteger",
              "alias": "objectid"
            }, {
              "name": "Geohash",
              "type": "esriFieldTypeString",
              "alias": "Geohash"
            }, {
              "name": "Count",
              "type": "esriFieldTypeInteger",
              "alias": "Count"
            }, {
              "name": "Weight",
              "type": "esriFieldTypeDouble",
              "alias": "Weight"
            }, {
              "name": "Geometry",
              "type": "esriFieldTypeGeometry",
              "alias": "Geometry"
            }
          ]
        };
        var featureCollection = {
          layerDefinition: layerDefinition,
          featureSet: {
            features: [],
            geometryType: layerDefinition.geometryType
          }
        };
        var infoTemplate = new InfoTemplate("Attributes", "${*}");
        var aggregationLayer = new FeatureLayer(featureCollection, {
          id: "aggregations",
          objectIdField: "objectid",
          showLabels: true,
          infoTemplate: infoTemplate,
          outFields: ["*"]
        });

        // Create and set the bins renderer
        var renderer = dojo.byId("useAggregationRenderer").checked === true ? createAggregationRenderer() : createClassBreakRenderer();
        aggregationLayer.setRenderer(renderer);
        
        // Create and set the bin labels (if renderLabels is checked)
        if (dojo.byId("renderLabels") && dojo.byId("renderLabels").checked === true) {
          var labelClass = createLabelClass();
          aggregationLayer.setLabelingInfo([labelClass]);
        }
        
        _map.addLayer(aggregationLayer);
        console.log("Client Aggregation Layer added");

        getLayerInfo();
        return aggregationLayer
      }

      /**
       * Adds a heatmap layer to the map with a predefined feature collection and renderer
       */
      function addHeatmapLayer() {
        var layerDefinition = {
          "geometryType": "esriGeometryPoint",
          "fields": [{
            "name": "objectid",
            "type": "esriFieldTypeInteger",
            "alias": "objectid"
                }, {
            "name": "Geohash",
            "type": "esriFieldTypeString",
            "alias": "Geohash"
                }, {
            "name": "Count",
            "type": "esriFieldTypeInteger",
            "alias": "Count"
                }, {
            "name": "Weight",
            "type": "esriFieldTypeDouble",
            "alias": "Weight"
                }, {
            "name": "geometry",
            "type": "esriFieldTypeGeometry",
            "alias": ""
                }]
        };

        var featureCollection = {
          layerDefinition: layerDefinition,
          featureSet: {
            features: [],
            geometryType: layerDefinition.geometryType
          }
        };

        var heatmapLayer = new FeatureLayer(featureCollection, {
          id: "heatmap",
          objectIdField: "objectid",
          visible: true,
          opacity: 1
        });

        // Create and set the renderer for the heatmap layer
        var renderer = createHeatmapRenderer();
        heatmapLayer.setRenderer(renderer);

        _map.addLayer(heatmapLayer);
        console.log("Heatmap Layer added");
      }

      /**
       * Queries the feature layer's time extent and sets the global _layerTimeExtent variable
       * This function is called when the map is loaded or when the layer is set
       */
      function queryLayerTimeExtent() {
        var url = dojo.byId("inputUrl").value + "?f=json";
        var request = esriRequest({
          "url": url,
          "handleAs": "json",
          "callbackParamName": "callback"
        });
        request.then(
          function (response) {
            _layerTimeExtent = new TimeExtent(new Date(response.timeInfo.timeExtent[0]), new Date(response.timeInfo.timeExtent[1]));
          },
          function (error) {
            console.log("Error getting the layers time extent: ", error.message);
          });
      }

      function loadBinRendererProps() {
        _binRendererProps.classBreaksCount = dojo.byId("classBreaksCount") ? dojo.byId("classBreaksCount").value : 10;
        console.log("Creating an aggregation renderer with " + _binRendererProps.classBreaksCount + " class breaks");

        // min and max fill color and opacity
        var minColorHex = dojo.byId("minColor") ? dojo.byId("minColor").value : "#000000";
        var maxColorHex = dojo.byId("maxColor") ? dojo.byId("maxColor").value : "#000000";
        var minColorA = dojo.byId("minColorA") ? parseFloat(dojo.byId("minColorA").value / 255) : 1.0;
        if (isNaN(minColorA) || minColorA < 0 || minColorA > 1) {
          minColorA = 1.0; // Default to fully opaque if invalid
        }
        var maxColorA = dojo.byId("maxColorA") ? parseFloat(dojo.byId("maxColorA").value / 255) : 1.0;
        if (isNaN(maxColorA) || maxColorA < 0 || maxColorA > 1) {
          maxColorA = 1.0; // Default to fully opaque if invalid
        }
        _binRendererProps.minColor = hexToRgba(minColorHex, minColorA);
        _binRendererProps.maxColor = hexToRgba(maxColorHex, maxColorA);

        // min and max outline color and opacity
        var minOutlineColorHex = dojo.byId("minOutlineColor") ? dojo.byId("minOutlineColor").value : "#000000";
        var maxOutlineColorHex = dojo.byId("maxOutlineColor") ? dojo.byId("maxOutlineColor").value : "#000000";
        var minOutlineColorA = dojo.byId("minOutlineColorA") ? parseFloat(dojo.byId("minOutlineColorA").value / 255) : 1.0;
        if (isNaN(minOutlineColorA) || minOutlineColorA < 0 || minOutlineColorA > 1) {
          minOutlineColorA = 1.0; // Default to fully opaque if invalid
        }
        var maxOutlineColorA = dojo.byId("maxOutlineColorA") ? parseFloat(dojo.byId("maxOutlineColorA").value / 255) : 1.0;
        if (isNaN(maxOutlineColorA) || maxOutlineColorA < 0 || maxOutlineColorA > 1) {
          maxOutlineColorA = 1.0; // Default to fully opaque if invalid
        }
        _binRendererProps.minOutlineColor = hexToRgba(minOutlineColorHex, minOutlineColorA);
        _binRendererProps.maxOutlineColor = hexToRgba(maxOutlineColorHex, maxOutlineColorA);

        // min and max outline width
        _binRendererProps.minOutlineWidth = dojo.byId("minOutlineWidth") ? parseFloat(dojo.byId("minOutlineWidth").value) : 0.5;
        _binRendererProps.maxOutlineWidth = dojo.byId("maxOutlineWidth") ? parseFloat(dojo.byId("maxOutlineWidth").value) : 1.0;
      }

      // Interpolates a value between min and max.
      // ratio is a value between 0 and 1
      // returns a value between min and max
      function interpolate(ratio, min, max) {
        if (max === min) return max;
        return min + ratio * (max - min);
      }

      function createClassBreakInfo(min, max) {
        var ratio = max / 100;

        // fill color and opacity
        var fillR = interpolate(ratio, _binRendererProps.minColor[0], _binRendererProps.maxColor[0]);
        var fillG = interpolate(ratio, _binRendererProps.minColor[1], _binRendererProps.maxColor[1]);
        var fillB = interpolate(ratio, _binRendererProps.minColor[2], _binRendererProps.maxColor[2]);
        var fillA = interpolate(ratio, _binRendererProps.minColor[3], _binRendererProps.maxColor[3]);
        var fillColor = new Color([fillR, fillG, fillB, fillA]);
        var fillSymbol = new SimpleFillSymbol()

        // outline color and width
        var outlineR = interpolate(ratio, _binRendererProps.minOutlineColor[0], _binRendererProps.maxOutlineColor[0]);
        var outlineG = interpolate(ratio, _binRendererProps.minOutlineColor[1], _binRendererProps.maxOutlineColor[1]);
        var outlineB = interpolate(ratio, _binRendererProps.minOutlineColor[2], _binRendererProps.maxOutlineColor[2]);
        var outlineA = interpolate(ratio, _binRendererProps.minOutlineColor[3], _binRendererProps.maxOutlineColor[3]);
        var outlineColor = new Color([outlineR, outlineG, outlineB, outlineA]);
        var outlineWidth = interpolate(ratio, _binRendererProps.minOutlineWidth, _binRendererProps.maxOutlineWidth);
        fillSymbol
                .setStyle(SimpleFillSymbol.STYLE_SOLID)
                .setColor(fillColor)
                .setOutline(
                        new SimpleLineSymbol().setColor(outlineColor).setWidth(outlineWidth)
                );
        return {
          minValue: min,
          maxValue: max,
          symbol: fillSymbol
        };
      }

      function buildAggregationRendererClassBreakInfos() {
        loadBinRendererProps();
        var classBreakInfos = [];
        var classSize = 100 / _binRendererProps.classBreaksCount;
        for (var i = 0; i < _binRendererProps.classBreaksCount; i++) {
          classBreakInfos.push(createClassBreakInfo(i * classSize, (i + 1) * classSize));
        }
        return classBreakInfos;
      }

      function buildAggregationRendererClassBreakInfos_Simple() {
        loadBinRendererProps();
        var classBreakInfos = [];
        classBreakInfos.push(createClassBreakInfo(0, 10));
        classBreakInfos.push(createClassBreakInfo(10, 20));
        classBreakInfos.push(createClassBreakInfo(20, 30));
        classBreakInfos.push(createClassBreakInfo(30, 40));
        classBreakInfos.push(createClassBreakInfo(40, 50));
        classBreakInfos.push(createClassBreakInfo(50, 60));
        classBreakInfos.push(createClassBreakInfo(60, 70));
        classBreakInfos.push(createClassBreakInfo(70, 80));
        classBreakInfos.push(createClassBreakInfo(80, 90));
        classBreakInfos.push(createClassBreakInfo(90, 100));
        return classBreakInfos;
      }

      function createAggregationRenderer() {
        var classBreakInfos = buildAggregationRendererClassBreakInfos();

        // define breaks and color
        var renderer = new ClassBreaksRenderer({
          field: "Weight",
          defaultSymbol: createClassBreakInfo(90, 100).symbol,
          normalizationType: "percent-of-total",
          normalizationTotal: 100,
          classBreakInfos: classBreakInfos
        });

        return renderer;
      }

      /**
       * Creates a ClassBreaksRenderer for the aggregation layer
       * This renderer defines different color breaks based on the "Weight" field
       * @returns {ClassBreaksRenderer} The created ClassBreaksRenderer instance
       */
       function createClassBreakRenderer() {
        console.log("Creating a class break renderer with 10 classes");

        // define default symbol
        var symbol = new SimpleFillSymbol();
        symbol.setColor(new Color([150, 150, 150, 0.3]))
          .setOutline(new SimpleLineSymbol().setColor(new Color("white")).setWidth(0.3));
        // function to create symbol for breaks with a given color
        function createSymbol(color) {
          return new SimpleFillSymbol()
            .setColor(color)
            .setOutline(
              new SimpleLineSymbol().setColor(new Color([99, 99, 99, 1])).setWidth(0.3)
            );
        };
        classColorInfo = [];

        // define breaks and color
        var renderer = new ClassBreaksRenderer({
          field: "Weight",
          defaultSymbol: symbol,
          normalizationType: "percent-of-total",
          normalizationTotal: 100,
          classBreakInfos: [
            {
              minValue: 0,
              maxValue: 10,
              symbol: createSymbol(new Color([254, 240, 217, 0.7]))
            },
            {
              minValue: 10,
              maxValue: 20,
              symbol: createSymbol(new Color([253, 212, 158, 0.7]))
            },
            {
              minValue: 20,
              maxValue: 30,
              symbol: createSymbol(new Color([253, 187, 132, 0.8]))
            },
            {
              minValue: 30,
              maxValue: 40,
              symbol: createSymbol(new Color([252, 141, 89, 0.8]))
            },
            {
              minValue: 40,
              maxValue: 60,
              symbol: createSymbol(new Color([239, 101, 72, 0.9]))
            },
            {
              minValue: 60,
              maxValue: 80,
              symbol: createSymbol(new Color([215, 48, 31, 0.9]))
            },
            {
              minValue: 80,
              maxValue: 100,
              symbol: createSymbol(new Color([153, 0, 0, 1]))
            }
          ]
        });

        return renderer;        
      }

      /**
       * Creates a HeatmapRenderer for the heatmap layer
       * This renderer defines color stops and blur radius for the heatmap visualization
       * @returns {HeatmapRenderer} The created HeatmapRenderer instance
       */
      function createHeatmapRenderer() {
          var renderer =  new HeatmapRenderer({
            colorStops: [
              {
                ratio: 0,
                color: "rgba(250, 0, 0, 0)"
                    },
              {
                ratio: 0.3,
                color: "rgba(0,128,255, 1)"
                    },
              {
                ratio: 0.4,
                color: "rgba(115,185,139, 1)"
                    },
              {
                ratio: 0.5,
                color: "rgba(185,220,69, 1)"
                    },
              {
                ratio: 0.6,
                color: "rgba(255,255,0, 1)"
                    },
              {
                ratio: 0.7,
                color: "rgb(255,220,0)"
                    },
              {
                ratio: 0.9,
                color: "rgb(255,174,0)"
                    },
              {
                ratio: 0.97,
                color: "rgb(255,112,0)"
                    },
              {
                ratio: 0.98,
                color: "rgb(255,80,0)"
                    },
              {
                ratio: 0.999,
                color: "rgb(255, 0, 0)"
                    }],
            blurRadius: 12,
            field: "Weight"
          });

          return renderer;
      }

      /**
       * Creates a LabelClass for the feature layer
       * This class defines the labeling properties for the features
       * @returns {LabelClass} The created LabelClass instance
       */
      function createLabelClass() {
        // Get label configuration from UI controls
        var labelFont = dijit.byId("labelFont") ? dijit.byId("labelFont").value : "arial";
        var labelStyle = dijit.byId("labelStyle") ? dijit.byId("labelStyle").value : "normal";
        var labelWeight = dijit.byId("labelWeight") ? dijit.byId("labelWeight").value : "normal";
        var labelSize = dojo.byId("labelSize") ? dojo.byId("labelSize").value + "pt" : "9pt";
        var labelColorHex = dojo.byId("labelColor") ? dojo.byId("labelColor").value : "#000000";
        var labelOpacity = dojo.byId("labelOpacity") ? parseFloat(dojo.byId("labelOpacity").value) : 1.0;
        
        // Convert hex color to RGB with opacity
        var labelColor = hexToRgb(labelColorHex);
        if (labelColor) {
          labelColor = [labelColor.r, labelColor.g, labelColor.b, labelOpacity];
        } else {
          labelColor = [0, 0, 0, labelOpacity]; // Default to black
        }

        // Create a text symbol for the label
        var textSymbol = new TextSymbol().setColor(new Color(labelColor));
        textSymbol.font.setSize(labelSize);
        textSymbol.font.setFamily(labelFont);
        textSymbol.font.setStyle(toFontStyle(labelStyle));
        textSymbol.font.setWeight(toFontWeight(labelWeight));


        // Create a label class with label expression and text symbol
        var labelJson = {
          "labelExpressionInfo": {
            "value": "{Weight}"
          },
          "labelPlacement": "always-horizontal"
        };
        var labelClass = new LabelClass(labelJson);
        labelClass.symbol = textSymbol;
        
        return labelClass;
      }

      // ### Utility Functions ###

      /**
       * Converts label style string to a valid font style
       * @param {string} labelStyle - The label style string (e.g., "italic", "oblique")
       * @returns {string} The corresponding font style ("normal", "italic", "oblique")
       */
      function toFontStyle(labelStyle) {
        // Convert label style string to font style
        if (!labelStyle || typeof labelStyle !== "string") {
          return "normal"; // Default to normal if no style is provided
        }

        if (labelStyle.toLowerCase().includes("italic")) {
          return "italic";
        }
        if (labelStyle.toLowerCase().includes("oblique")) {
          return "oblique";
        }

        // default to normal if no specific style is found
        return "normal";
      }

      /**
       * Converts label weight string to a valid font weight
       * @param {string} labelWeight - The label weight string (e.g., "bold", "bolder", "lighter")
       * @returns {string} The corresponding font weight ("normal", "bold", "bolder", "lighter")
       */
      function toFontWeight(labelWeight) {
        // Convert label style string to font weight
        if (!labelWeight || typeof labelWeight !== "string") {
          return "normal"; // Default to normal if no style is provided
        }

        if (labelWeight.toLowerCase().includes("bold")) {
          return "bold";
        }
        if (labelWeight.toLowerCase().includes("bolder")) {
          return "bolder";
        }
        if (labelWeight.toLowerCase().includes("lighter")) {
          return "lighter";
        }

        // default to normal if no specific weight is found
        return "normal";
      }

      /**
       * Converts a hexadecimal color string to RGB values
       * Used for processing label color settings from the UI
       * @param {string} hex - Hexadecimal color string (e.g., "#FF0000")
       * @returns {Object|null} RGB object with r, g, b properties or null if invalid
       */
      function hexToRgb(hex) {
        // Convert hex color to RGB using regex pattern matching
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }

      /**
       * Converts a hexadecimal color string to RGBA values
       * @param {string} hex - Hexadecimal color string (e.g., "#FF0000")
       * @param {number} a - Alpha value (0-1)
       * @returns {Array|null} Array with r, g, b, a values or null if invalid
       */
      function hexToRgba(hex, a) {
        const hexWithoutHash = hex.replace("#", "");

        const r = parseInt(hexWithoutHash.substring(0, 2), 16);
        const g = parseInt(hexWithoutHash.substring(2, 4), 16);
        const b = parseInt(hexWithoutHash.substring(4, 6), 16);

        return [r, g, b, a];
      }

      /**
       * Builds the query URL based on the current UI settings
       * This function constructs the URL for querying the feature layer (or MSL) with LOD, time, and spatial filters
       * @returns {string} The constructed query URL
       */
      function buildQueryUrlFromUI() {
        var timeParam = "";
        if (_replay) {
          var start = _layerTimeExtent.startTime.getTime();
          var end = _layerTimeExtent.endTime.getTime();
          timeParam = "&time=" + start + "," + end;
        } else if (_live) {
          var now = new Date().getTime();
          timeParam = "&time=null," + now;
        }

        var lod = dojo.byId("lod").value;
        var lodSubType = dojo.byId("aggSubStyle").value;
        var lodType = dojo.byId("aggStyle").value;
        if (dojo.byId("autoOffSet").checked === true) {
          if (lodType === "flatHexagon" || lodType === "pointyHexagon" || lodType === "square" || lodType === 'geotile') {
            lod = (parseInt(lod) + 5).toString();
          } else if (lodType === "flatTriangle" || lodType === "pointyTriangle") {
            lod = (parseInt(lod) + 4).toString();
          } else if (lodType === 'h3') {
            lod = (parseInt(lod) + 0).toString();
          }
        }

        // Build the query URL
        var url = dojo.byId("inputUrl").value;
        var outSR = _currentMapSR;
        url += "/query?lod=" + lod + "&lodType=" + lodType + "&lodSubType=" + lodSubType + "&outSR=" + outSR;
        if (dojo.byId("useLodSR") && dojo.byId("useLodSR").checked === true) {
          var lodSR = dijit.byId("lodSpatialReference").value;
          url += "&lodSR=" + lodSR;
        }
        url +=  "&returnGeometry=true" + timeParam;


        // TODO - for now, add the spatial filter to the query, only for point geometry layers
        if (_layerInfo && _layerInfo.geometryType && _layerInfo.geometryType === "esriGeometryPoint") {
          var ext = encodeURIComponent(JSON.stringify(_map.extent.toJson()));
          url += "&geometryType=esriGeometryEnvelope&geometry=" + ext;
        }

        url += "&f=pjson";

        if (dojo.byId("useStats").checked === true) {
          var outStatisticsObj = [ {
            "statisticType": dijit.byId("statType").value,
            "onStatisticField": dijit.byId("statField").value,
            "outStatisticFieldName": dijit.byId("statField").value + "_" + dijit.byId("statType").value
          } ];
          var outStatisticsStr = JSON.stringify(outStatisticsObj);
          url += "&outStatistics=" + encodeURIComponent(outStatisticsStr);
        }

        //console.log(url);
        return url;
      }

      function toggleUseAggregationRenderer() {
        if (dojo.byId("useAggregationRenderer").checked === true) {
          dojo.byId("aggregationRendererControls").style.display = "block";
        } else {
          dojo.byId("aggregationRendererControls").style.display = "none";
        }

        updateRendererFromUI();
      }

      /**
       * Updates the layer renderer and label based on UI changes
       * This function is called when label-related UI controls are changed
       */
      function updateRendererFromUI() {
        var aggregationLayer = _map.getLayer("aggregations");
        if (!aggregationLayer) {
          console.log("Aggregation layer not found.");
          return;
        }

        // Create and set the bins renderer
        var renderer = dojo.byId("useAggregationRenderer").checked === true ? createAggregationRenderer() : createClassBreakRenderer();
        aggregationLayer.setRenderer(renderer);

        // Create and set the bin labels (if renderLabels is checked)
        if (dojo.byId("renderLabels") && dojo.byId("renderLabels").checked === true) {
          var labelClass = createLabelClass();
          aggregationLayer.setLabelingInfo([labelClass]);
        } else {
          aggregationLayer.setLabelingInfo([]);
        }

        aggregationLayer.refresh();
      }

      /**
       * Updates the aggregation layer based on UI changes
       * This function is called when any UI control that affects the layer is changed
       * @param {boolean} setMapExtent - Whether to set the map extent after updating the layer
       */
      function updateLayerFromUIChange(setMapExtent) {
        // Use current map spatial reference or LOD SR if enabled
        var outputSR = _currentMapSR;
        var sr = new SpatialReference(parseInt(outputSR));
        var mapSR = new SpatialReference(_map.spatialReference.wkid);

        var url = buildQueryUrlFromUI();
        var request = esriRequest({
          "url": url,
          "handleAs": "json",
          "callbackParamName": "callback"
        });
        request.then(
          function (response) {
            // Defensive: ensure features is always an array
            response.features = Array.isArray(response.features) ? response.features : [];

            var aggregationsLayer = _map.getLayer("aggregations");
            var heatmapLayer = _map.getLayer("heatmap");
            if (!aggregationsLayer || !heatmapLayer)
              return;

            var weightsArray = [];

            // If the output SR is different from map SR, we need to project geometries
            if (parseInt(outputSR) !== _map.spatialReference.wkid) {
              // Project all geometries to map's spatial reference
              var geometriesToProject = [];
              array.forEach(response.features, function(feature) {
                if (feature && feature.geometry) {
                  feature.geometry.spatialReference = sr.toJson();
                  geometriesToProject.push(new Polygon(feature.geometry));
                }
              });

              if (geometriesToProject.length > 0) {
                var projectTask = _gs.project(geometriesToProject, mapSR);
                projectTask.then(function(projectedGeometries) {
                  processProjectedFeatures(response.features, projectedGeometries, weightsArray, setMapExtent);
                }, function(error) {
                  console.log("Error projecting geometries:", error);
                  // Fallback: process without projection
                  processFeatures(response.features, weightsArray, setMapExtent);
                });
              }
            } else {
              // No projection needed
              processFeatures(response.features, weightsArray, setMapExtent);
            }
          },
          function (error) {
            console.log("Error querying the aggregations: ", error.message);
          });
      }

      /**
       * Processes projected features and updates the layers with graphics
       * This function is called after geometries are projected to the map's spatial reference
       * @param {Array} features - The array of features to process
       * @param {Array} projectedGeometries - The array of projected geometries corresponding to the features
       * @param {Array} weightsArray - The array to store weights for each feature
       * @param {boolean} setMapExtent - Whether to set the map extent after updating the layer
       */
      // This function creates graphics from the projected geometries and updates the layers with them
      // It also calculates weights based on the selected statistics field and type
      // If heatmap is enabled, it uses the centroid of the geometry
      // If statistics are used, it retrieves the weight from the feature attributes
      // If not, it uses the "Count" attribute as the weight
      function processProjectedFeatures(features, projectedGeometries, weightsArray, setMapExtent) {
        features = Array.isArray(features) ? features : [];

        var graphics = array.map(features, function (feature, i) {
          var geometry = projectedGeometries[i];

          if (dojo.byId("heatmap").checked === true) {
            geometry = geometry.getCentroid();
          }

          var weight = 0;
          if (dojo.byId("useStats").checked === true) {
            var weightFieldName = dijit.byId("statField").value + "_" + dijit.byId("statType").value;
            weight = feature.attributes[weightFieldName];
          } else {
            weight = feature.attributes["Count"];
          }
          feature.attributes["Weight"] = number.round(weight, 2);
          weightsArray.push(weight);

          var graphic = new Graphic(geometry, null, feature.attributes, null);
          return graphic;
        });

        updateLayersWithGraphics(graphics, weightsArray, setMapExtent);
      }

      function processFeatures(features, weightsArray, setMapExtent) {
        features = Array.isArray(features) ? features : [];
        var mapSR = new SpatialReference(_map.spatialReference.wkid);
        
        // create features (graphics) from the response features
        var graphics = array.map(features, function (feature, i) {
            // Ensure the geometry has the correct spatial reference that matches the map
            if (feature && feature.geometry) {
              // Set the spatial reference to match the map's spatial reference
              feature.geometry['spatialReference'] = mapSR.toJson();
            }

            // create the polygon
            var geometry = new Polygon(feature.geometry);

            if (dojo.byId("heatmap").checked === true) {
              geometry = geometry.getCentroid();
            }

            var weight = 0;
            if (dojo.byId("useStats").checked === true) {
              var weightFieldName = dijit.byId("statField").value + "_" + dijit.byId("statType").value;
              weight = feature.attributes[weightFieldName];
            } else {
              weight = feature.attributes["Count"];
            }
            feature.attributes["Weight"] = number.round(weight, 2);
            weightsArray.push(weight);

            var graphic = new Graphic(geometry, null, feature.attributes, null);
            return graphic;
        });

        updateLayersWithGraphics(graphics, weightsArray, setMapExtent);
      }

      /**
       * Updates the aggregations and heatmap layers with the provided graphics
       * This function is called after querying the feature layer and processing the features
       * @param {Array} graphics - The array of graphics to update the layers with
       * @param {Array} weightsArray - The array of weights corresponding to the graphics
       * @param {boolean} setMapExtent - Whether to set the map extent after updating the layer
       */
      // This function updates the selected layer (heatmap or aggregations) with the new graphics
      // It also adjusts the renderer based on the selected layer and updates the map extent if needed
      // If the heatmap layer is selected, it sets the blur radius from the UI control
      function updateLayersWithGraphics(graphics, weightsArray, setMapExtent) {
        var aggregationsLayer = _map.getLayer("aggregations");
        var heatmapLayer = _map.getLayer("heatmap");

        // add features to the respective selected layer and adjust renderer
        var selectedLayer = null;
        var otherLayer = null;
        if (dojo.byId("heatmap").checked === true) {
          selectedLayer = heatmapLayer;
          otherLayer = aggregationsLayer;
          heatmapLayer.renderer.setBlurRadius(dojo.byId("blurRadius").value);
        } else {
          selectedLayer = aggregationsLayer;
          otherLayer = heatmapLayer;

          // calculate min and max weight values to adjust heatmap renderer
          _minValue = Math.min.apply(null, weightsArray);
          _maxValue = Math.max.apply(null, weightsArray);
          aggregationsLayer.renderer.normalizationTotal = _maxValue;
        }

        // update features layer with new features (graphics)
        otherLayer.setVisibility(false);
        selectedLayer.clear();
        selectedLayer.setVisibility(true);
        selectedLayer.applyEdits(graphics, null, null)
          .then(function () {
            if (setMapExtent && graphics.length > 0) {
              var layerExtent = graphicsUtils.graphicsExtent(graphics);
              if (layerExtent)
                _map.setExtent(layerExtent.expand(1.0));
            }
            selectedLayer.refresh();
          });
      }


      //#############################################################################################
      //Other Functions
      //#############################################################################################
      //

      /**
       * Initializes (init & update including labels) the time slider for the map
       */
      function initTimeSlider() {
        timeSlider = new TimeSlider({
          style: "width: 100%;"
        }, dom.byId("timeSlider"));
        _map.setTimeSlider(timeSlider);
        timeSlider.setThumbCount(2);
        timeSlider.createTimeStopsByCount(_layerTimeExtent, 21);
        timeSlider.setThumbIndexes([0, 21]);
        timeSlider.setThumbMovingRate(2000);
        timeSlider.startup();
        timeSlider.on("time-extent-change", function () {
          if (!_ignoreChangeEvent) {
            _layerTimeExtent = timeSlider.getCurrentTimeExtent();
            updateLayerFromUIChange();
          };
        });
        // add labels for every other time stop
        var labels = createLabels();
        timeSlider.setLabels(labels);
      }

      function updateTimeSlider() {
        queryLayerTimeExtent();
        setTimeout(function () {
          timeSlider.createTimeStopsByCount(_layerTimeExtent, 21);
          timeSlider.setThumbIndexes([0, 21]);
          timeSlider.startup();
          _map.setTimeSlider(timeSlider);
          // add labels for every other time stop
          var labels = createLabels();
          timeSlider.setLabels(labels);
          domStyle.set(dom.byId('timeSlider'), "display", 'block');
          updateLayerFromUIChange();
          _ignoreChangeEvent = false;
        }, 1000);
      }

      // time slider labels
      function createLabels() {
        var labels = array.map(timeSlider.timeStops, function (timeStop, i) {
          if (i % 2 === 0) {
            if (timeStop.getHours() < 10) {
              var hours = "0" + timeStop.getHours();
            } else {
              var hours = timeStop.getHours();
            };
            if (timeStop.getMinutes() < 10) {
              var minutes = "0" + timeStop.getMinutes();
            } else {
              var minutes = timeStop.getMinutes();
            };
            if (timeStop.getSeconds() < 10) {
              var seconds = "0" + timeStop.getSeconds();
            } else {
              var seconds = timeStop.getSeconds();
            };
            var month = timeStop.getMonth() + 1;
            var day = timeStop.getDate();
            //return hours + ":" + minutes;
            return month + "/" + day + "<br>" + hours + ":" + minutes + ":" + seconds;
          } else {
            return "";
          }
        });
        return labels;
      }

      function autoUpdate() {
        setTimeout(function () {
          updateLayerFromUIChange();
          if (_live) {
            autoUpdate();
          }
        }, 2000);
      }

      on(dom.byId("inputUrl"), "mouseenter", function() {
        this.title = this.value || "No value entered";
      });
      on(dom.byId("inputUrl"), "mouseleave", function() {
        this.title = "";
      });

      function onSelectedBasemapChanged() {
        // Get the selected basemap URL from the dropdown
        var basemapUrl = dom.byId("basemapUrl").value;
        console.log("Selected basemap URL: ", basemapUrl);

        // Check if the map object is initialized
        if (!_map) {
          console.error("Map object is not initialized.");
          return;
        }

        // Remove the existing basemap layer if it exists
        var basemapLayer = _map.getLayer("basemap");
        if (basemapLayer) {
          console.log("Removing existing basemap layer.");
          _map.removeLayer(basemapLayer);
        }

        // Add the new basemap layer
        var newBasemapLayer;
        if (_isBasemapTiled) {
          newBasemapLayer = new ArcGISTiledMapServiceLayer(basemapUrl, { id: "basemap" });
        } else {
          newBasemapLayer = new ArcGISDynamicMapServiceLayer(basemapUrl, { id: "basemap", opacity: 1.0 });
        }
        _map.addLayer(newBasemapLayer);

        console.log("Basemap updated to: " + basemapUrl);
      }

      require(["dojo/domReady!"], function() {
        var basemapDropdown = dom.byId("basemapUrl");
        if (basemapDropdown) {
          // Attach the event listener to the basemap dropdown
          on(basemapDropdown, "change", onSelectedBasemapChanged);
        } else {
          console.warn("Element with ID 'basemapUrl' not found in the DOM.");
        }
      });
    });
  </script>
</head>

<body class="flat">
  <div id="map"></div>
  <div id="timeSlider"></div>
  <div class="collapser">
    <i id="collapserIcon" class="flat-chevron-right"></i>
    <i id="expanderIcon" class="flat-chevron-left"></i>
  </div>
  <div id="controls">
    <!-- [Section 1] Layers -->
    <section id="layersSection">
      <div class="config-header">
        <h2>Layers</h2>
        <div class="header-actions-group">
          <a href="#" id="layersToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>

      <div class="config-content">
        <!-- Layer -->
        <div class="input-row">
          <input type="text" id="inputUrl" value="https://storm.esri.com:6443/arcgis/rest/services/faa/MapServer/0" />
          <input type="button" class="button" id="setLayerButton" value="Set Layer" />
        </div>

        <!-- Select Basemap -->
        <div class="input-group input-group-full">
          <select id="basemapUrl" name="basemapUrl" style="width: 120px;">
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Topo_Map/MapServer">Topographic</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer">Streets</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer">National Geographic</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Canvas/World_Light_Gray_Base/MapServer">Light Gray Canvas</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Canvas/World_Dark_Gray_Base/MapServer">Dark Gray Canvas</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer">Imagery</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Terrain_Base/MapServer">Terrain</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/World_Shaded_Relief/MapServer">Shaded Relief</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Transportation/MapServer">Transportation</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Reference_Overlay/MapServer">World Reference</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer">Oceans</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/USA_Topo_Maps/MapServer">USA Topo Maps</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Specialty/World_Navigation_Charts/MapServer">Navigation Charts</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Boundaries_and_Places/MapServer">Boundaries and Places</option>
            <option value="https://services.arcgisonline.com/arcgis/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer">Boundaries and Places Alternate</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer">USGS National Map</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer">USGS Imagery</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer">USGS Imagery with Labels</option>
            <option value="https://basemap.nationalmap.gov/arcgis/rest/services/USGSHydroCached/MapServer">USGS Hydro</option>
          </select>
          <label for="basemapUrl">Basemap</label>
        </div>

        <!-- Select Map SR -->
        <div class="input-group input-group-full">
          <select name="spatialReferenceSelect" data-dojo-type="dijit/form/Select" id="spatialReferenceSelect" style="width: 200px;">
            <option value="102003">102003 (Albers)</option>
            <option value="102100" selected="selected">102100 (Web Mercator)</option>
            <option value="4326">4326 (WGS84)</option>
            <option value="54030">54030 (Robinson)</option>
            <option value="26911">26911 (NAD83 / UTM zone 11N)</option>
            <option value="27700">27700 (British National Grid)</option>
            <option value="2243">2243 (Idaho West, State Plane)</option>
            <option value="2244">2244 (Indiana East, State Plane)</option>
            <option value="2248">2248 (Maryland, State Plane)</option>
            <option value="3995">3995 (Arctic Polar Stereographic)</option>
            <option value="2271">2271 (NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="2272">2272 (NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
            <option value="3363">3363 (NAD_1983_HARN_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
            <option value="3365">3365 (NAD_1983_HARN_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
          </select>
          <label for="spatialReferenceSelect">Spatial Reference</label>
        </div>

        <!-- Current Map SR -->
        <div class="input-group input-group-full">
          <input type="text" id="currentMapSR" value="102100" readonly />
          <label for="currentMapSR">Current</label>
        </div>
      </div>
    </section>

    <!-- [Section 2] Aggregation Settings -->
    <section id="aggSettingsSection">
      <div class="config-header">
        <h2>Aggregation Settings</h2>
        <div class="header-actions-group">
          <a href="#" id="aggSettingsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content" style="padding-bottom: 5px;">
        <div class="input-group input-group-full">
          <input type="number" id="lod" value="3" />
          <label for="lod">LOD</label>
        </div>
        <div class="input-group input-group-full input-group-checkbox-full">
          <label for="autoOffSet">Auto offset</label>
          <input type="checkbox" id="autoOffSet" checked="true" title="Auto Offset LOD based on the LOD type:
            GeoHash: 0
            Geotile: 5
            H3: 0
            Square: 5
            Flat Hexagon: 5
            Pointy Hexagon: 5
            Flat Triangle: 4
            Pointy Triangle: 4"/>
        </div>
      </div>
    </section>

    <!-- [Section 3] Aggregation Style -->
    <section id="aggStyleSection">
      <div class="config-header">
        <h2>Aggregation Style</h2>
        <div class="header-actions-group">
          <a href="#" id="aggStyleToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content" style="padding-bottom: 5px;">
        <div class="input-group input-group-full">
          <select name="aggStyle" id="aggStyle" style="width: 120px;">
            <option value="geohash" selected="selected">GeoHash</option>
            <option value="geotile">GeoTile</option>
            <option value="h3">H3</option>
            <option value="square">Square</option>
            <option value="flatHexagon">Flat Hexagon</option>
            <option value="pointyHexagon">Pointy Hexagon</option>
            <option value="flatTriangle">Flat Triangle</option>
            <option value="pointyTriangle">Pointy Triangle</option>
          </select>
          <label for="aggStyle">LOD Type</label>
        </div>
        <div class="input-group input-group-full">
          <select name="aggSubStyle" id="aggSubStyle" style="width: 120px;">
            <option value="shape">Shape</option>
            <option value="centroid" selected="selected">Centroid</option>
          </select>
          <label for="aggSubStyle">LOD SubType</label>
        </div>
      </div>
      <div class="config-content" style="padding-top: 0;">
        <label for="useLodSR">LOD SR</label>
        <input type="checkbox" id="useLodSR" />
        <select name="lodSpatialReference" data-dojo-type="dijit/form/Select" id="lodSpatialReference" style="width: 200px;">
          <option value="102003">102003 (Albers)</option>
          <option value="102100" selected="selected">102100 (Web Mercator)</option>
          <option value="4326">4326 (WGS84)</option>
          <option value="54030">54030 (Robinson)</option>
          <option value="26911">26911 (NAD83 / UTM zone 11N)</option>
          <option value="27700">27700 (British National Grid)</option>
          <option value="2243">2243 (Idaho West, State Plane)</option>
          <option value="2244">2244 (Indiana East, State Plane)</option>
          <option value="2248">2248 (Maryland, State Plane)</option>
          <option value="3995">3995 (Arctic Polar Stereographic)</option>
          <option value="2271">2271 (NAD_1983_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
          <option value="2272">2272 (NAD_1983_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
          <option value="3363">3363 (NAD_1983_HARN_StatePlane_Pennsylvania_North_FIPS_3701_Feet)</option>
          <option value="3365">3365 (NAD_1983_HARN_StatePlane_Pennsylvania_South_FIPS_3702_Feet)</option>
        </select>
      </div>
    </section>

    <!-- [Section 4] Aggregation Bins Section -->
    <section id="aggBinsSection">
      <div class="config-header">
        <h2>Aggregation Bins</h2>
        <div class="header-actions-group">
          <input type="checkbox" id="useAggregationRenderer" title="Use Aggregation Renderer"/>
          <a href="#" id="aggBinsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div id="aggregationRendererControls" style="display: none;">
        <div class="config-content" style="padding-bottom: 0px;">
          <div class="input-row input-row-header-labeled">
            <label>Min</label>
            <label>Max</label>
          </div>
          <div class="input-row input-row-header">
            <label>Fill Color</label>
            <input title="Min Fill Color" type="color" value="#ff0000" id="minColor" style="width: 20%;"/>
            <input title="Max Fill Color" type="color" value="#ff0000" id="maxColor" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Fill Opacity</label>
            <input title="Min Fill Opacity" type="number" min="0" max="255" id="minColorA" value="0" style="width: 20%;"/>
            <input title="Max Fill Opacity" type="number" min="0" max="255" id="maxColorA" value="255" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Outline Color</label>
            <input title="Min Outline Color" type="color" value="#000000" id="minOutlineColor" style="width: 20%;"/>
            <input title="Max Outline Color" type="color" value="#000000" id="maxOutlineColor" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Outline Opacity</label>
            <input title="Min Outline Opacity" type="number" min="0" max="255" id="minOutlineColorA" value="100" style="width: 20%;"/>
            <input title="Max Outline Opacity" type="number" min="0" max="255" id="maxOutlineColorA" value="100" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" >
            <label>Outline Width</label>
            <input title="Min Outline Width" type="number" min="0" id="minOutlineWidth" value="0.5" style="width: 20%;"/>
            <input title="Max Outline Width" type="number" min="0" id="maxOutlineWidth" value="0.5" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" id="ovalAttrSection" style="display: none;" >
            <label>Size</label>
            <input title="Min Size in Precent" type="number" min="0" max="100" placeholder="min" id="minSize" value="100" style="width: 20%;"/>
            <input title="Max Size in Precent" type="number" min="0" max="100" placeholder="max" id="maxSize" value="100" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header">
            <label>Range</label>
            <input title="Min Value. Leave empty to auto-calculate dynamically based on actual values in the current extent." type="number" id="minValue" value="" placeholder="min" style="width: 20%;"/>
            <input title="Max Value. Leave empty to auto-calculate dynamically based on actual values in the current extent." type="number" id="maxValue" value="" placeholder="max" style="width: 20%;"/>
          </div>
          <div class="input-row input-row-header" style="justify-content: flex-start;">
            <label for="classBreaksCount">Class Breaks</label>
            <input type="number" id="classBreaksCount" value="10" min="2"/>
          </div>
        </div>
      </div>
      <div class="config-content">
        <div class="input-row input-row-header" style="justify-content: flex-start;">
          <label for="heatmap">Heatmap</label>
          <input type="checkbox" id="heatmap" />
        </div>
        <div id="radius" class="input-row input-row-header" style="justify-content:flex-start; display:none;">
          <label for="blurRadius">Blur Radius</label>
          <input type="number" id="blurRadius" value="10" style="width: 40px;" />
        </div>
        <div class="input-row input-row-header" style="justify-content: flex-start;">
          <label for="useStats">Statistics</label>
          <input type="checkbox" id="useStats" style="top:4px;"/>
        </div>
        <div class="input-row input-row-header">
          <label></label>
          <select name="statField" data-dojo-type="dijit/form/Select" data-dojo-attach-point="statField"
            id="statField"
            style="width: 250px; margin-top:3px; display:none; float:left;">
          </select>
        </div>
        <div class="input-row input-row-header">
          <label></label>
          <select name="statType" data-dojo-type="dijit/form/Select" data-dojo-attach-point="statType"
            id="statType"
            style="width: 250px; margin-top:3px; display:none; float:left;">
          </select>
        </div>
      </div>
    </section>

    <!-- [Section 5] Aggregation Labels Section -->
    <section id="aggLabelsMainSection">
      <div class="config-header">
        <h2>Aggregation Labels</h2>
        <div class="header-actions-group">
          <input type="checkbox" id="renderLabels" checked="true" title="Render Labels"/>
          <a href="#" id="aggLabelsToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>

      <div id="aggLabelsSection" class="config-content">

        <!-- Label Font -->
        <div class="input-group input-group-full">
          <select name="labelFont" data-dojo-type="dijit/form/Select" id="labelFont" style="width: 99%;">
            <option value="arial" selected="selected">Arial</option>
            <option value="arial black">Arial Black</option>
            <option value="arial narrow">Arial Narrow</option>
            <option value="brush script mt">Brush Script MT</option>
            <option value="comic sans ms">Comic Sans MS</option>
            <option value="courier">Courier</option>
            <option value="courier new">Courier New</option>
            <option value="cursive">Cursive</option>  
            <option value="custom">Custom</option>
            <option value="fantasy">Fantasy</option> 
            <option value="garamond">Garamond</option>
            <option value="georgia">Georgia</option>
            <option value="helvetica">Helvetica</option>
            <option value="impact">Impact</option>
            <option value="lucida console">Lucida Console</option>
            <option value="lucida grande">Lucida Grande</option>
            <option value="lucida sans unicode">Lucida Sans Unicode</option>
            <option value="monospace">Monospace</option>
            <option value="palatino">Palatino</option>
            <option value="segoe ui">Segoe UI</option>
            <option value="sans-serif">Sans Serif</option>
            <option value="serif">Serif</option>
            <option value="symbol">Symbol</option>
            <option value="tahoma">Tahoma</option>
            <option value="times">Times</option>
            <option value="times new roman">Times New Roman</option>
            <option value="trebuchet ms">Trebuchet MS</option>
            <option value="verdana">Verdana</option>
            <option value="webdings">Webdings</option>
            <option value="wingdings">Wingdings</option>
            <option value="zapf dingbats">Zapf Dingbats</option>
          </select>
          <label for="labelFont">Font</label>
        </div>

        <!-- Label Style -->
        <div class="input-group input-group-full">
          <select name="labelStyle" data-dojo-type="dijit/form/Select" id="labelStyle" style="width: 99%;">
            <option value="normal">Normal</option>
            <option value="italic">Italic</option>
            <option value="oblique">Oblique</option>
          </select>
          <label for="labelStyle">Style</label>
        </div>

        <!-- Label Weight -->
        <div class="input-group input-group-full">
          <select name="labelWeight" data-dojo-type="dijit/form/Select" id="labelWeight" style="width: 99%;">
            <option value="normal">Normal</option>
            <option value="bold">Bold</option>
            <option value="bolder">Bolder</option>
            <option value="lighter">Lighter</option>
          </select>
          <label for="labelStyle">Weight</label>
        </div>

        <!-- Label Size -->
        <div class="input-group">
          <input type="number" id="labelSize" value="9" style="width: 60px;"/>
          <label for="labelSize">Size</label>
        </div>
        <!-- Label Color -->
        <div class="input-group">
          <input type="color" value="#000000" id="labelColor" style="width: 60px;"/>
          <label for="labelColor">Color</label>
        </div>
        <!-- Label Opacity -->
        <div class="input-group">
          <!--input type="number" min="0" max="255" id="labelColorA" value="255" style="width: 60px;"/-->
          <input type="range" id="labelOpacity" min="0" max="1" step="0.02" value="1" style="width: 100px;" />
          <label for="labelOpacity">Opacity</label>
        </div>

      </div>
    </section>

    <!-- [Section 6] Streaming Mode Section -->
    <section id="streamingModeSection">
      <div class="config-header">
        <h2>Streaming Mode</h2>
        <div class="header-actions-group">
          <a href="#" id="streamingModeToggle"><i class="fa fa-chevron-up"></i></a>
        </div>
      </div>
      <div class="config-content">
        <div class="input-group">
          <select name="aggStreamMode" id="refreshMode" style="width: 120px;">
            <option value="manual">Manual</option>
            <option value="live">Live</option>
            <option value="replay">Replay</option>
          </select>
          <label for="refreshMode">Mode</label>
        </div>
      </div>
    </section>

  </div>
</body>

</html>
